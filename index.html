<html><head><style>body {
   color: black;
}
</style></head><body><p><img src="_page_0_Picture_1.jpeg" alt=""></p>
<h1 id="-optimize-your-game-performance-for-consoles-and-pcs-in-unity-"><strong>Optimize your game performance for consoles and PCs in Unity</strong></h1>
<p><img src="_page_0_Picture_3.jpeg" alt=""></p>
<p><img src="_page_0_Picture_4.jpeg" alt=""></p>
<h2 id="-contents-"><strong>Contents</strong></h2>
<table>
<thead>
<tr>
<th>Introduction 8</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Profiling 9</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Profile early, often, and on the target device 9</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Focus on optimizing the right areas 10</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Understand how the Unity Profiler works 11</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Deep Profiling 15</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Use the Profile Analyzer 15</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Frames per second: A deceptive metric 17</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Determine if you are GPU-bound or CPU-bound 18</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Use native profiling and debugging tools 19</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Native profiling tools 19</td>
<td></td>
</tr>
<tr>
<td></td>
<td>GPU debugging and profiling tools 20</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Project Auditor 20</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Memory 21</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Use the Memory Profiler 22</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Reduce the impact of garbage collection (GC) 22</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Time garbage collection whenever possible 23</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Use the Incremental Garbage Collector</td>
<td></td>
</tr>
<tr>
<td></td>
<td>to split the GC workload 24</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Assets 25</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Compress textures 25</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Texture import settings 26</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Atlas your textures 27</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Check your polygon counts 28</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Mesh import settings 30</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Other mesh optimizations 30</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Audit your assets 31</th>
</tr>
</thead>
<tbody>
<tr>
<td>The AssetPostprocessor 31</td>
</tr>
<tr>
<td>UnityDataTools 31</td>
</tr>
<tr>
<td>Async texture buffer 31</td>
</tr>
<tr>
<td>Stream mipmaps and textures 32</td>
</tr>
<tr>
<td>Use Addressables 33</td>
</tr>
<tr>
<td>Programming and code architecture 36</td>
</tr>
<tr>
<td>Understand the Unity PlayerLoop 36</td>
</tr>
<tr>
<td>Minimize code that runs every frame 38</td>
</tr>
<tr>
<td>Avoid heavy logic in Start/Awake 38</td>
</tr>
<tr>
<td>Cache the results of expensive functions 39</td>
</tr>
<tr>
<td>Avoid empty Unity event functions 40</td>
</tr>
<tr>
<td>Build a custom Update Manager 40</td>
</tr>
<tr>
<td>Remove Debug Log statements 41</td>
</tr>
<tr>
<td>Disable Stack Trace logging 42</td>
</tr>
<tr>
<td>Use hash values instead of string parameters 42</td>
</tr>
<tr>
<td>Choose the right data structure 43</td>
</tr>
<tr>
<td>Avoid adding components at runtime 43</td>
</tr>
<tr>
<td>Use object pools 43</td>
</tr>
<tr>
<td>Transform once, not twice 44</td>
</tr>
<tr>
<td>Use ScriptableObjects 45</td>
</tr>
<tr>
<td>Avoid lambda expressions 46</td>
</tr>
<tr>
<td>The C# job system 46</td>
</tr>
<tr>
<td>The Burst compiler 48</td>
</tr>
<tr>
<td>Project configuration 50</td>
</tr>
<tr>
<td>Disable unnecessary Player or Quality settings 50</td>
</tr>
<tr>
<td>Switch to IL2CPP 50</td>
</tr>
<tr>
<td>Avoid large hierarchies 51</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Graphics 52</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Commit to a render pipeline 52</td>
<td></td>
</tr>
<tr>
<td>Around 90% of Unity games on PC/console<br>are using SRPs 53</td>
<td></td>
</tr>
<tr>
<td>Render pipeline packages for consoles 55</td>
<td></td>
</tr>
<tr>
<td>Select a rendering path 56</td>
<td></td>
</tr>
<tr>
<td>Forward 57</td>
<td></td>
</tr>
<tr>
<td>Forward + 57</td>
<td></td>
</tr>
<tr>
<td>Deferred shading 58</td>
<td></td>
</tr>
<tr>
<td>Optimize Shader Graph 59</td>
<td></td>
</tr>
<tr>
<td>Remove built-in shader settings 61</td>
<td></td>
</tr>
<tr>
<td>Strip shader variants 61</td>
<td></td>
</tr>
<tr>
<td>Particle simulations: Particle System or VFX Graph63</td>
<td></td>
</tr>
<tr>
<td>Smooth with anti-aliasing 64</td>
<td></td>
</tr>
<tr>
<td>Spatial-Temporal Post-Processing 66</td>
<td></td>
</tr>
<tr>
<td>Common lighting optimizations 67</td>
<td></td>
</tr>
<tr>
<td>Bake lightmaps 67</td>
<td></td>
</tr>
<tr>
<td>Minimize reflection probes 68</td>
<td></td>
</tr>
<tr>
<td>Adaptive Probe Volumes 68</td>
<td></td>
</tr>
<tr>
<td>Disable shadows 70</td>
<td></td>
</tr>
<tr>
<td>Substitute a shader effect 70</td>
<td></td>
</tr>
<tr>
<td>Use Light Layers 71</td>
<td></td>
</tr>
<tr>
<td>GPU Lightmapper 71</td>
<td></td>
</tr>
<tr>
<td>GPU optimization 72</td>
<td></td>
</tr>
<tr>
<td>Benchmark the GPU 72</td>
<td></td>
</tr>
<tr>
<td>Watch the rendering statistics 73</td>
<td></td>
</tr>
<tr>
<td>Use draw call batching 74</td>
<td></td>
</tr>
<tr>
<td>Check the Frame Debugger 76</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Optimize fill rate and reduce overdraw 77</th>
</tr>
</thead>
<tbody>
<tr>
<td>Draw order and render queues 77</td>
</tr>
<tr>
<td>Optimizing graphics for consoles 81</td>
</tr>
<tr>
<td>Identify your performance bottlenecks 81</td>
</tr>
<tr>
<td>Reduce the batch count 82</td>
</tr>
<tr>
<td>Profile the post-processing 82</td>
</tr>
<tr>
<td>Avoid tessellation shaders 82</td>
</tr>
<tr>
<td>Replace geometry shaders with compute shaders. 82</td>
</tr>
<tr>
<td>Aim for good wavefront occupancy 83</td>
</tr>
<tr>
<td>Use HDRP built-in and custom passes 84</td>
</tr>
<tr>
<td>Reduce the size of shadow mapping</td>
</tr>
<tr>
<td>render targets 84</td>
</tr>
<tr>
<td>Utilize Async Compute 84</td>
</tr>
<tr>
<td>Culling 86</td>
</tr>
<tr>
<td>Dynamic resolution 88</td>
</tr>
<tr>
<td>Multiple camera views 88</td>
</tr>
<tr>
<td>Render Objects Renderer Feature in URP 90</td>
</tr>
<tr>
<td>Custom Pass Volumes in HDRP 91</td>
</tr>
<tr>
<td>Use Level of Detail (LOD) 92</td>
</tr>
<tr>
<td>Profile post-processing effects 93</td>
</tr>
<tr>
<td>GPU Resident Drawer 93</td>
</tr>
<tr>
<td>GPU occlusion culling 95</td>
</tr>
<tr>
<td>Split Graphics Jobs 96</td>
</tr>
<tr>
<td>User interface 97</td>
</tr>
<tr>
<td>User interface 97</td>
</tr>
<tr>
<td>UGUI performance optimization tips 97</td>
</tr>
<tr>
<td>Divide your Canvases 97</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Hide invisible UI elements 98</th>
</tr>
</thead>
<tbody>
<tr>
<td>Limit GraphicRaycasters and disable<br>Raycast Target 98</td>
</tr>
<tr>
<td>Avoid Layout Groups 99</td>
</tr>
<tr>
<td>Avoid large List and Grid views 99</td>
</tr>
<tr>
<td>Avoid numerous overlaid elements 99</td>
</tr>
<tr>
<td>When using a fullscreen UI, hide everything else . 99</td>
</tr>
<tr>
<td>Assign the Camera to World Space<br>and Camera Space Canvases 99</td>
</tr>
<tr>
<td>UI Toolkit performance optimization tips 100</td>
</tr>
<tr>
<td>Use efficient layouts 100</td>
</tr>
<tr>
<td>Avoid expensive operations in Update 100</td>
</tr>
<tr>
<td>Optimize event handling 100</td>
</tr>
<tr>
<td>Optimize style sheets 101</td>
</tr>
<tr>
<td>Profile and optimize 101</td>
</tr>
<tr>
<td>Test on target platforms 101</td>
</tr>
<tr>
<td>Audio 102</td>
</tr>
<tr>
<td>Use lossless files as your source 102</td>
</tr>
<tr>
<td>Reduce your AudioClip 103</td>
</tr>
<tr>
<td>AudioClip Import Settings 103</td>
</tr>
<tr>
<td>Optimize the AudioMixer 105</td>
</tr>
<tr>
<td>Physics 107</td>
</tr>
<tr>
<td>Simplify colliders 108</td>
</tr>
<tr>
<td>Optimize your settings 109</td>
</tr>
<tr>
<td>Adjust simulation frequency 110</td>
</tr>
<tr>
<td>Modify CookingOptions for MeshColliders 112</td>
</tr>
<tr>
<td>Use Physics.BakeMesh 113</td>
</tr>
<tr>
<td>Use Box Pruning for large scenes 113</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Modify solver iterations 115</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disable automatic transform syncing 116</td>
</tr>
<tr>
<td>When to manually sync 116</td>
</tr>
<tr>
<td>Performance best practice 116</td>
</tr>
<tr>
<td>Use Contact Arrays 117</td>
</tr>
<tr>
<td>Reuse Collision Callbacks 117</td>
</tr>
<tr>
<td>Move static colliders 118</td>
</tr>
<tr>
<td>Use non-allocating queries 118</td>
</tr>
<tr>
<td>2D Physics 118</td>
</tr>
<tr>
<td>Batch queries for ray casting 119</td>
</tr>
<tr>
<td>Visualize with the Physics Debugger 119</td>
</tr>
<tr>
<td>Animation 120</td>
</tr>
<tr>
<td>Use generic rather than humanoid rigs 120</td>
</tr>
<tr>
<td>Use alternatives for simple animation 121</td>
</tr>
<tr>
<td>Avoid scale curves 121</td>
</tr>
<tr>
<td>Update only when visible 121</td>
</tr>
<tr>
<td>Optimize workflow 121</td>
</tr>
<tr>
<td>Separate animating hierarchies 122</td>
</tr>
<tr>
<td>Minimize binding costs 122</td>
</tr>
<tr>
<td>Avoid using component-based constraints on deep<br>hierarchies 122</td>
</tr>
<tr>
<td>Consider performance implications<br>of animation rigging 122</td>
</tr>
<tr>
<td>Workflow and collaboration 123</td>
</tr>
<tr>
<td>Use version control 123</td>
</tr>
<tr>
<td>Unity Version Control 124</td>
</tr>
<tr>
<td>Break up large scenes 126</td>
</tr>
<tr>
<td>Resources for advanced developers and artists 127</td>
</tr>
</tbody>
</table>
<h2 id="-span-id-page-7-0-span-introduction"><span id="page-7-0"></span>Introduction</h2>
<p>This guide brings together all the best and latest PC and console performance optimization tips available in Unity 6. It is one of two optimization guides available for Unity 6, the other being <em><a href="https://unity.com/resources/mobile-xr-web-game-performance-optimization-unity-6">Optimize your game performance for mobile, XR, and Unity Web in Unity 6</a></em>.</p>
<p>Performance optimization is a vast topic that requires careful attention. In order to find an efficient solution that satisfies your design requirements, you will need to master Unity&#39;s classes and components, algorithms and data structures, and your platform&#39;s profiling tools.</p>
<p>Optimizing your console or PC application is an essential process that underpins the entire game development cycle. While your audience may take it for granted that your game runs at silky-smooth 60+ frames per second (fps), achieving your performance goals across multiple platforms is not always easy. To optimize effectively requires effort to make both your code architecture and art assets more efficient and an understanding of how your target hardware operates within its limitations.</p>
<p>This guide assembles knowledge and advice from Unity&#39;s expert software engineers who have tested these best practices with our industry partners in real-world scenarios.</p>
<p>Follow these steps to get the best performance from your PC and console game.</p>
<h2 id="-span-id-page-8-0-span-profiling"><span id="page-8-0"></span>Profiling</h2>
<h4 id="profile-early-often-and-on-the-target-device">Profile early, often, and on the target device</h4>
<p>Profiling is the process of measuring aspects of your game&#39;s performance at runtime and therefore, it&#39;s at the heart of any optimization workflow. It&#39;s key to understand the suite of profiling tools available both from Unity and the manufacturer of your target hardware.</p>
<p>It&#39;s essential that you can measure how your game runs on its target platform and use this information to track down the cause of a performance problem. By watching the profiling tool as you make changes, you can gauge whether the changes actually fix the performance problem.</p>
<p>The <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Profiler.html?">Unity Profiler</a> provides performance information about your application, but it can&#39;t help you if you don&#39;t use it.</p>
<p>Profiling is the process of measuring aspects of your game&#39;s performance at runtime and to track down the cause of a performance problem. By monitoring the profiling tool as you make changes, you can gauge whether changes actually fix the performance problem.</p>
<p>Profile your project early and throughout the development cycle, not just when you are close to shipping. Investigate glitches or spikes as soon as they appear and make sure to benchmark performance before and after major changes in your project. As you develop a &quot;performance signature&quot; for your project, you&#39;ll be able to spot new issues more easily.</p>
<p>While profiling in the Editor can give you an idea of the relative performance of different systems in your game, profiling on each device gives you the opportunity to gain more</p>
<p><span id="page-9-0"></span><img src="_page_9_Picture_0.jpeg" alt=""></p>
<p>accurate insights. Profile a development build on target devices whenever possible. Remember to profile and optimize for both the highest- and lowest-spec devices that you plan to support.</p>
<p>Unity offers a suite of profiling tools to help identify bottlenecks including the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Profiler.html?">Unity Profiler</a>, the <a href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.1/manual/index.html">Memory Profiler</a> and <a href="https://docs.unity3d.com/Packages/com.unity.performance.profile-analyzer@1.2/manual/index.html">Profile Analyzer.</a></p>
<h4 id="focus-on-optimizing-the-right-areas">Focus on optimizing the right areas</h4>
<p>Don&#39;t guess or make assumptions about what is slowing down your game&#39;s performance. Use the Unity Profiler and platform-specific tools to locate the precise source of a lag. Profiling tools ultimately help you understand what&#39;s going on under the hood of your Unity project. But don&#39;t wait for significant performance problems to start showing before digging into your detective toolbox.</p>
<p>Of course, not every optimization described here will apply to your application. Something that works well in one project may not translate to yours. Identify genuine bottlenecks and concentrate your efforts on what benefits your work.</p>
<p>To learn more about how to plan your profiling workflows see the <em><a href="https://unity.com/resources/ultimate-guide-to-profiling-unity-games?isGated=false">Ultimate guide to profiling</a>  <a href="https://unity.com/resources/ultimate-guide-to-profiling-unity-games?isGated=false">Unity games</a></em>.</p>
<p><img src="_page_9_Picture_8.jpeg" alt=""></p>
<p><span id="page-10-0"></span><img src="_page_10_Picture_0.jpeg" alt=""></p>
<p><img src="_page_10_Figure_1.jpeg" alt=""></p>
<p>Follow this workflow for profiling your Unity projects efficiently.</p>
<h2 id="understand-how-the-unity-profiler-works">Understand how the Unity Profiler works</h2>
<p>The Unity Profiler can help you detect the causes of any bottlenecks or freezes at runtime and better understand what&#39;s happening at a specific frame or point in time.</p>
<p>The Profiler is instrumentation-based. It profiles timings of game and engine code that are automatically marked up (such as MonoBehaviour&#39;s Start or Update methods, or specific API calls), or explicitly wrapped with the help of <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Unity.Profiling.ProfilerMarker.html?">ProfilerMarker</a> API.</p>
<p>Begin by enabling the CPU and Memory tracks as your default. You can monitor supplementary Profiler Modules like Renderer, Audio, and Physics as needed for your game (for example, profiling as needed for physics-heavy or music-based gameplay). However, only enable what you need so you don&#39;t impact performance and skew your results.</p>
<table>
<thead>
<tr>
<th>C. Profiler</th>
<th></th>
<th>×ロ×</th>
</tr>
</thead>
<tbody>
<tr>
<td>Profiler Modules</td>
<td>· Playmode · (2) 14 Pl Frame: 3023 / 3182 Clear<br>Clear on Play Deep Profile Call Stacks ▼</td>
<td>1 0 @ 1</td>
</tr>
<tr>
<td>CPU Usage</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Rendering<br>Scripts</td>
<td>16ms (60FPS)</td>
<td></td>
</tr>
<tr>
<td>Physics</td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Animation<br>GarbageCollector</td>
<td>1.74ms<br>1.99ms<br>10ms (100FPS)</td>
<td></td>
</tr>
<tr>
<td>· VSync</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Global Illumination<br>5</td>
<td>Sms (200FPS)</td>
<td></td>
</tr>
<tr>
<td>Others</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&amp; Rendering</td>
<td>239 -</td>
<td></td>
</tr>
<tr>
<td>Batches Count</td>
<td>106<br>136.15k<br>115,68k</td>
<td></td>
</tr>
<tr>
<td>· SetPass Calls Count</td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Thangles Count<br>· Vertices Count</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O Memory</td>
<td>0.96 GB 0.73 GB<br>-6.1 MB 195</td>
<td></td>
</tr>
<tr>
<td>· Total Used Memory<br>· Texture Memory</td>
<td>10.03K<br>91.5 MB</td>
<td></td>
</tr>
<tr>
<td>· Mesh Memory</td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Material Count<br>Object Count</td>
<td>0,9 KE</td>
<td></td>
</tr>
<tr>
<td>· GC Used Memory</td>
<td></td>
<td></td>
</tr>
<tr>
<td>GC Allocated In Frame</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Timeline</td>
<td>CPU:12.32ms GPU :- ms<br>· Live</td>
<td></td>
</tr>
<tr>
<td>Main Thread</td>
<td>750 (ARDL (APP) (400) (400) (400) (430) (430) (430) (430) (430) (430) (430) (450) (450) (450) (450) (450) (450) (450) (450) (450) (450) (450) (450) (450) (450) (450) (450) (4<br>PlayerLoop (1.82ms)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>RenderPipelineManager.DoRenderLoop_Internal() (1.68ms)<br>Int UnivercalRendor Total (1.68ms)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>In_RenderCameraStack (1.67ms)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Ini_UniversalRonderPlyellno.RonderSingleCamora: Main Camera (0.49ms)<br>eginCamera imeFrame<br>Ini_Context.Submit (0.53ms)<br>CullScriptsble (0.24ms)<br>UniversalRonderPipeline.RenderSingleComera: Main Camera (0.48ms)</td>
<td></td>
</tr>
<tr>
<td>Render Thread</td>
<td>der = ScriptableRanderer, Execute: BoatDemoRenderer (0.22<br>UniversalRenderPipeline.RenderSingleCamera: Main Camera (0.48ms)<br>Gfz.WaitForGfxCommandsFromMainThread (0.38ms)<br>Gfx WaitForGfxCommandsFromMainThread (0.22ms)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ScriptableRenderer Execute: BoatDemoRenderer (0.45ms)<br>Semaphore. Wait For Signall (0.38ms)<br>Semaphore.WaitForSignal (0,22ms)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ghtShadow (D) PpacurObjects (O.C.) = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</td>
<td></td>
</tr>
<tr>
<td>&gt; Job<br>Loading</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Scripting Threads</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Background Job</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Profiler</td>
<td>Cam and san Mad Carline at 13 00mm<br>HabTa of Honak 18 Coller</td>
<td>Com nothers link Corlland 11 18 as at</td>
</tr>
<tr>
<td>Other Threads</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Audio</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AssetDatabase</td>
<td></td>
<td></td>
</tr>
<tr>
<td>BakingJobs</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CloudJob</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Use the Unity Profiler to test performance and resource allocation.</p>
<p>To capture profiling data from an actual device within your chosen platform, check the <strong>Development Build</strong> before you click Build and Run. Then, connect the Profiler to your application manually once it&#39;s running.</p>
<p>You can optionally check <strong>Autoconnect Profiler</strong> under <strong>Platform Settings</strong> in the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/build-profiles.html">Build Profiles</a> window. Sometimes this is useful if you specifically want to capture the first few frames of the application. Be warned that this option can add 5–10 seconds of startup time, so only use it when necessary.</p>
<p><img src="_page_12_Picture_0.jpeg" alt=""></p>
<table>
<thead>
<tr>
<th></th>
<th>Build Profiles</th>
<th></th>
<th></th>
<th>×</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Build Profilios</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Add Build Profile</td>
<td></td>
<td>Player Settings Learn about Unity Dev Ops. Asset Import Overrides</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Piatforms<br>Scene List<br>Active<br>Windows<br>Android™</td>
<td>Windows<br>1</td>
<td></td>
<td>Build And Run<br>Build</td>
</tr>
<tr>
<td></td>
<td>SOF S<br>WebGL<br>&amp; macos<br>@ Linux<br>至 Windows Server</td>
<td>Build Data<br>Y Scene List</td>
<td>Packers builds was the shared some int. To cline settings independently, crosts a Build Profile for this platfym. Add Build Profile</td>
<td></td>
</tr>
<tr>
<td></td>
<td>E macOS Server<br>Linux Server<br>· Play Station®4<br>· PlayStation®5</td>
<td>&gt; Scenes/SampleScene</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>Universal Windows Platform<br>SONE #</td>
<td></td>
<td></td>
<td>Open Scene List</td>
</tr>
<tr>
<td></td>
<td>Build Profiles</td>
<td>Platform Sottings<br>Windows Settings</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Welcome to Build Profiles.</td>
<td>Architecture</td>
<td>Intel 64-bit</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Add a Bulld Profile to configure as<br>many builds as you need for any<br>supported platform. Build profiles<br>are stored as assets you can<br>share with your team.<br>Add Build Profile</td>
<td>Build and Run on<br>Copy PDB files<br>Create Visual Studio Solution<br>Development Build<br>Autoconnect Profiler<br>Deep Profiling Support<br>Script Debugging</td>
<td>Local Machine<br>ﺍﻟﻤﺴﺎﻋﺪ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘﻮﻯ ﺍﻟﻤﺴﺘ<br>S<br>€<br>1<br>1</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Compression Method</td>
<td>Default</td>
</tr>
</tbody>
</table>
<p>Adjust your Platform Settings before profiling.</p>
<p>Choose the platform target to profile. The Record button tracks several seconds of your application&#39;s playback (300 frames by default). Go to <strong>Unity &gt; Preferences &gt; Analysis &gt; Profiler &gt; Frame Count</strong> to increase this up to 2000 if you need longer captures. While this costs more CPU and memory resources, it can be useful depending on your specific scenario.</p>
<p><img src="_page_12_Figure_4.jpeg" alt=""></p>
<p>Use the Timeline view to determine if you are CPU-bound or GPU-bound.</p>
<p><img src="_page_13_Picture_0.jpeg" alt=""></p>
<p>When using the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ProfilerWindow.html">Deep Profiling s</a>etting, Unity can profile the beginning and end of every function call in your script code, telling you exactly which part of your application is being executed and potentially causing a delay. However, deep profiling adds overhead to every method call and may skew the performance analysis.</p>
<p>Click in the window to analyze a specific frame. Next, use either the Timeline or Hierarchy view for the following:</p>
<ul>
<li><strong>Timeline</strong> shows the visual breakdown of timing for a specific frame. This allows you to visualize how the activities relate to one another and across different threads. Use this option to determine if you are CPU- or GPU-bound.</li>
<li><strong>Hierarchy</strong> shows the hierarchy of ProfileMarkers, grouped together. This allows you to sort the samples based on time cost in milliseconds (Time ms and Self ms). You can also count the number of Calls to a function and the managed heap memory (GC Alloc) on the frame.</li>
</ul>
<p><img src="_page_13_Picture_5.jpeg" alt=""></p>
<p>The Hierarchy view allows you to sort ProfileMarkers by time cost.</p>
<p>If you&#39;re new to profiling, start with this series of short video tutorials:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=xjsqv8nj0cw&amp;t=1s">Profiler walkthrough</a></li>
<li><a href="https://www.youtube.com/watch?v=Ypg84Fr20Sw&amp;t=1s">Profile Analyzer walkthrough</a></li>
<li><a href="https://www.youtube.com/watch?v=Uuzd39AjFWQ&amp;t=1s">Memory Profiler walkthrough</a></li>
</ul>
<p>For a complete overview of the Unity Profiler, download the profiling e-book <a href="https://unity.com/resources/ultimate-guide-to-profiling-unity-games?isGated=false">here.</a></p>
<p><span id="page-14-0"></span><img src="_page_14_Picture_0.jpeg" alt=""></p>
<p>Before optimizing anything in your project, save the Profiler .data file. Implement your changes and compare the saved .data before and after the modification. Rely on this cycle to improve performance: profile, optimize, and compare.</p>
<h4 id="-deep-profiling-"><strong>Deep Profiling</strong></h4>
<p>You can also enable <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ProfilerWindow.html">Deep Profiling Support</a> in the Build Settings. When the built Player starts, the Deep Profiler profiles every part of your code, not just code timings explicitly wrapped in <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Unity.Profiling.ProfilerMarker.html">ProfilerMarkers.</a></p>
<p>When Deep Profiling is enabled, Unity can profile the beginning and end of every function call in your script code. This can help you identify exactly which part of your application is causing a slowdown.</p>
<p>However, Deep Profiling is resource intensive and uses a lot of memory. Each ProfilerMarker adds a tiny bit of overhead (about 10ns, depending on the platform), so each additional point of measurement slows your application more. Also, be warned that if you have a lot of function calls, deep profiling amplifies their overhead as well.</p>
<p>If you want to see more details on samples with markers such as <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/profiler-markers.html">GC.Alloc</a> or <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/profiler-markers.html">JobHandle.</a> <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/profiler-markers.html">Complete</a>, navigate to the Profiler window toolbar and enable the <strong>Call Stacks</strong> setting. This provides the sample&#39;s full call stack, which gives you the information you need without incurring the overhead of Deep Profiling.</p>
<p><img src="_page_14_Figure_8.jpeg" alt=""></p>
<h3 id="use-the-profile-analyzer">Use the Profile Analyzer</h3>
<p>The Profile Analyzer lets you aggregate multiple frames of Profiler data, then locate frames of interest. Do you want to see what happens to the Profiler after you make a change to your project? The <strong>Compare</strong> view allows you to load and differentiate two data sets, so you can test changes and improve their outcome. The <a href="https://docs.unity3d.com/Packages/com.unity.performance.profile-analyzer@1.2/manual/index.html">Profile Analyzer</a> is available via Unity&#39;s Package Manager.</p>
<table>
<thead>
<tr>
<th>Profile Analyzer</th>
<th>Compare Export Close Profiler Window</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>X ■ ×</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mode: Single</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pull Data</td>
<td></td>
<td>117.77ms ▼</td>
<td>33.00ms</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Frame Summary</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Load</td>
<td>Save VikingVillage_Left_MacPlayer_Wind</td>
<td>0.00ms</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Left</td>
<td>Right</td>
<td>Diff</td>
</tr>
<tr>
<td>Pull Data</td>
<td></td>
<td>117.77ms ▼</td>
<td></td>
<td></td>
<td>184 [262] 445</td>
<td></td>
<td></td>
<td></td>
<td>Gag</td>
<td>Frame Count</td>
<td>262</td>
<td>262</td>
<td>O</td>
</tr>
<tr>
<td>Load</td>
<td>Save VikingVillage_Right_MacPlayer_Win</td>
<td>0.00ms</td>
<td>33.00ms</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Start</td>
<td>184</td>
<td>184</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>184 [262] 445</td>
<td></td>
<td></td>
<td></td>
<td>999</td>
<td>End</td>
<td>445</td>
<td>445</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>&gt; 2 Pair Graph Selection</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>PlayerLoop</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>ms</td>
<td>ms</td>
<td>ms</td>
</tr>
<tr>
<td>v Filters</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Max</td>
<td>22.91</td>
<td>16.10</td>
<td>-6.80</td>
</tr>
<tr>
<td>Remove :</td>
<td>None</td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Upper Quartile</td>
<td>16.61</td>
<td>12.05</td>
<td>-4.56</td>
</tr>
<tr>
<td>Name Filter :</td>
<td>All ▼</td>
<td></td>
<td>Exclude Names : Any ▼</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Median</td>
<td>15.63</td>
<td>11.35</td>
<td>-4.28</td>
</tr>
<tr>
<td>Thread :</td>
<td>Select Main Thread</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Mean</td>
<td>15.90</td>
<td>11.60</td>
<td>-4.30</td>
</tr>
<tr>
<td>Depth Slice :</td>
<td>All + + Auto Depth (Diff: None)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Analysis Type: Total</td>
<td></td>
<td></td>
<td></td>
<td>Lower Quartile</td>
<td>14.90</td>
<td>10.80</td>
<td>-4.10</td>
</tr>
<tr>
<td>Parent Marker :</td>
<td>Clear PlayerLoop</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Units :</td>
<td></td>
<td>Milliseconds</td>
<td></td>
<td>Min</td>
<td>13.71</td>
<td>9.62</td>
<td>-4.10</td>
</tr>
<tr>
<td>Compare</td>
<td>494 of 554 markers , 1 of 47 threads</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Marker Columns : Time and Count</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>22.905</td>
</tr>
<tr>
<td></td>
<td>Top 10 markers on median frames</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>219</td>
<td>FinishFrameRe Render</td>
<td>GBuffer</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>94.1ms</td>
<td>0</td>
<td>22,905</td>
<td></td>
<td>O</td>
</tr>
<tr>
<td>292</td>
<td>PlayerLoop<br>PlayerLoop<br>FinishFrameR Render</td>
<td>GBuffer</td>
<td>Drawing Opaqt<br>Drawing Opaqı Cu</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>65.0ms</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(All depths)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Ratio: Normalized</td>
<td></td>
<td>Thread Summary</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Lett</td>
<td>Right</td>
<td>Total</td>
</tr>
<tr>
<td></td>
<td>Marker Comparison for currently selected range</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Total Count :</td>
<td>47</td>
<td>47</td>
<td>47</td>
</tr>
<tr>
<td>Marker Name</td>
<td></td>
<td>Left Mei &lt;</td>
<td>&gt;</td>
<td>Right Mc Diff</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Abs Diff Count L Count R Count D</td>
<td>Unique Count :</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PlayerLoop</td>
<td></td>
<td>15.60</td>
<td></td>
<td>11,31</td>
<td>-4.29</td>
<td>4.29</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td>Selected :</td>
<td></td>
<td>11</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>PostLateUpdate.FinishFrameRendering</td>
<td>12.14</td>
<td></td>
<td>8.02</td>
<td>-4.12</td>
<td>4.12</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td>Graph Scale :</td>
<td>Upper quartile</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Camera. Render</td>
<td></td>
<td>11.60</td>
<td></td>
<td>7.57</td>
<td>-4.04</td>
<td>4.04</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td></td>
<td>Median</td>
<td>Thread</td>
<td></td>
</tr>
<tr>
<td>RenderDeferred.GBuffer</td>
<td></td>
<td>9.76</td>
<td></td>
<td>5,78</td>
<td>-3.98</td>
<td>3.98</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td>-11 15.60</td>
<td>Main Thread</td>
<td></td>
</tr>
<tr>
<td>Drawing</td>
<td></td>
<td>7.85</td>
<td></td>
<td>4.80</td>
<td>-3.05</td>
<td>3.05</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td>-11.31</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Render. Opaque Geometry</td>
<td></td>
<td>6.06</td>
<td></td>
<td>3.65</td>
<td>-2.41</td>
<td>2.41</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>BatchRenderer.Flush</td>
<td></td>
<td>1.41</td>
<td></td>
<td>0.61</td>
<td>-0.80</td>
<td>0.80</td>
<td>45512</td>
<td>24812</td>
<td>-20700</td>
<td>Marker Summary</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>WaitForJobGroupID</td>
<td></td>
<td>2.02</td>
<td></td>
<td>1.23</td>
<td>-0.79</td>
<td>0.79</td>
<td>3999</td>
<td>3622</td>
<td>-377</td>
<td>PlayerLoop</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RenderForward.RenderLoopJob</td>
<td></td>
<td>0.94</td>
<td></td>
<td>0.38</td>
<td>-0.56</td>
<td>0.56</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td>Mean frame contribution</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Culling</td>
<td></td>
<td>2.49</td>
<td></td>
<td>1.93</td>
<td>-0.56</td>
<td>0.56</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td>Left</td>
<td>Right</td>
<td>Diff</td>
</tr>
<tr>
<td>Render. TransparentGeometry</td>
<td></td>
<td>0.98</td>
<td></td>
<td>0.48</td>
<td>-0.50</td>
<td>0.50</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td>99.79%</td>
<td>99.65%</td>
<td>-0.14%</td>
</tr>
<tr>
<td>RenderForwardAlpha.Render</td>
<td></td>
<td>0.71</td>
<td></td>
<td>0.28</td>
<td>-0.43</td>
<td>0.43</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td>First frame</td>
<td>184</td>
<td>184</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Cull Results. Create Shared Renderer Scene</td>
<td>1.01</td>
<td></td>
<td>0.66</td>
<td>-0.35</td>
<td>0.35</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td>Top 3 ▼ by frame costs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SceneCulling</td>
<td></td>
<td>1.34</td>
<td></td>
<td>1.05</td>
<td>-0.28</td>
<td>0.28</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td>22.87</td>
<td>16.07</td>
<td>-6.81</td>
</tr>
</tbody>
</table>
<p>Take an even deeper dive into frames and marker data with the <a href="https://docs.unity3d.com/Packages/com.unity.performance.profile-analyzer@1.0/manual/index.html?">Profile Analyzer</a>, which complements the existing Profiler.</p>
<p><a href="https://www.youtube.com/watch?v=Ypg84Fr20Sw&amp;t=1s">Watch this Profile Analyzer tutorial</a> to learn more about its features.</p>
<h4 id="-work-on-a-specific-time-budget-per-frame-"><strong>Work on a specific time budget per frame</strong></h4>
<p>Each frame will have a time budget based on your target frames per second (fps). For an application to run at 30 fps, its frame budget can&#39;t exceed 33.33 ms per frame (1000 ms / 30 fps). Likewise, a target of 60 fps leaves 16.66 ms per frame.</p>
<p><span id="page-16-0"></span><img src="_page_16_Picture_0.jpeg" alt=""></p>
<h4 id="-frames-per-second-a-deceptive-metric-"><strong>Frames per second: A deceptive metric</strong></h4>
<p>A common way that gamers measure performance is with frame rate, or frames per second. This can, however, be a deceptive metric when gauging your application&#39;s performance.</p>
<p>We recommend that you use frame time in milliseconds instead. To understand why, look at this graph of <strong>fps versus Frame Time</strong>:</p>
<p><img src="_page_16_Figure_5.jpeg" alt=""></p>
<p>If you look at the differences between 60 fps and 56.25 fps, that translates into 16.666 milliseconds per frame and 17.777 milliseconds per frame, respectively. This also represents 1.111 milliseconds extra per frame, but here, the drop in frame rate feels far less dramatic percentage-wise.</p>
<p><span id="page-17-0"></span><img src="_page_17_Picture_0.jpeg" alt=""></p>
<p>This is why developers use the average frame time to benchmark game speed rather than fps.</p>
<p>Don&#39;t worry about fps unless you drop below your target frame rate. Focus on frame time to measure how fast your game is running, then stay within your frame budget.</p>
<p>Read the original article, <a href="http://www.mvps.org/directx/articles/fps_versus_frame_time.htm">&quot;Robert Dunlop&#39;s FPS versus Frame Time,</a>&quot; for more information.</p>
<h2 id="determine-if-you-are-gpu-bound-or-cpu-bound">Determine if you are GPU-bound or CPU-bound</h2>
<p>The central processing unit (CPU) is responsible for determining what must be drawn, and the graphics processing unit (GPU) is responsible for drawing it.</p>
<p>When the CPU takes too long to process and prepare the frame for the GPU, then the overall frame rate is limited by the CPU&#39;s performance – it becomes CPU bound.</p>
<p>Similarly, when the GPU takes too long to render the frame after it has been prepared by the CPU, it&#39;s GPU bound.</p>
<p>The Profiler can tell you if your CPU is taking longer than your allotted frame budget, or if the culprit is your GPU. It does this by <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/profiler-markers.html">emitting markers prefixed with Gfx</a> as follows:</p>
<ul>
<li>If you see the <strong>Gfx.WaitForCommands</strong> marker, it means that the render thread is ready, but you might be waiting for a bottleneck on the main thread.</li>
<li>If you frequently encounter <strong>Gfx.WaitForPresentOnGfxThread</strong>, it means that the main thread was ready but was waiting for the render thread. This might indicate that your application is GPU-bound. Check the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ProfilerCPU.html">CPU Profiler module&#39;s Timeline view</a> to see activity on the render thread.</li>
</ul>
<p>If the render thread spends time in <strong>Camera.Render</strong>, your application is CPU-bound and might be spending too much time sending draw calls or textures to the GPU.</p>
<p>If the render thread spends time in <strong>Gfx.PresentFrame</strong>, your application is GPU-bound or might be <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/profiler-markers.html#rendering">waiting for VSync</a> on the GPU.</p>
<p>Refer to the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/profiler-markers.html?">Common Profiler markers</a> documentation for a complete list of markers. Also, check out our blog post on <a href="https://blog.unity.com/technology/fixing-time-deltatime-in-unity-2020-2-for-smoother-gameplay-what-did-it-take?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-multiplatform&amp;utm_content=optimize-game-performance-2020-lts-ebook">Fixing Time.deltaTime in Unity 2020.2 for smoother gameplay</a> for more information about the frame pipeline.</p>
<h2 id="-span-id-page-18-0-span-use-native-profiling-and-debugging-tools"><span id="page-18-0"></span>Use native profiling and debugging tools</h2>
<p>Start your profiling with Unity&#39;s tools, and if you need greater detail, reach for the native profiling and debugging tools available for your target platform.</p>
<h4 id="-native-profiling-tools-"><strong>Native profiling tools</strong></h4>
<h4 id="-intel-"><strong>Intel</strong></h4>
<ul>
<li><a href="https://software.intel.com/en-us/intel-vtune-amplifier-xe">Intel VTune:</a> Quickly find and fix performance bottlenecks on Intel platforms with this suite of tools for Intel processors only.</li>
<li><a href="https://software.intel.com/content/www/us/en/develop/tools/graphics-performance-analyzers.html">Intel GPA suite:</a> This suite of graphics-focused tools can help you improve your game&#39;s performance by quickly identifying problem areas.</li>
</ul>
<h4 id="-xbox-consoles-and-windows-pc-"><strong>Xbox consoles and Windows PC</strong></h4>
<p>— <a href="https://devblogs.microsoft.com/pix/introduction/">PIX</a>: PIX is a performance tuning and debugging tool for Windows and Xbox console game developers using DirectX 12. It includes tools for understanding and analyzing CPU and GPU performance, as well as monitoring various real-time performance counters. For Windows developers, <a href="https://devblogs.microsoft.com/pix/download/">start here</a>. For more details about PIX for Xbox, you need to be a registered Xbox developer: <a href="https://www.xbox.com/en-US/developers/id">Start here</a>.</p>
<h4 id="-pc-universal-"><strong>PC / Universal</strong></h4>
<ul>
<li><a href="https://developer.amd.com/amd-uprof/">AMD μProf</a>: AMD uProf is a performance analysis tool for understanding and profiling performance for applications running on AMD hardware.</li>
<li><a href="https://developer.nvidia.com/tools-overview">NVIDIA NSight Developer Tools</a>: This tooling enables developers to build, debug, profile, and develop class-leading and cutting-edge software using the latest accelerated computing hardware from NVIDIA.</li>
<li><a href="https://superluminal.eu/">Superluminal:</a> Superluminal is a high-performance, high-frequency profiler that supports profiling applications on Windows, Xbox consoles, and PlayStation® written in C++, Rust and .NET. It is a paid product, though, and must be licensed for use.</li>
</ul>
<h4 id="-playstation-"><strong>PlayStation®</strong></h4>
<p>— CPU profiler tools are available for the PlayStation development environment. For more details, you need to be a registered PlayStation developer: <a href="https://partners.playstation.net/">Start here.</a></p>
<h4 id="-web-"><strong>Web</strong></h4>
<ul>
<li><a href="https://profiler.firefox.com/">Firefox Profiler:</a> Dig into the call stacks and view flame graphs for Unity Web builds (among other things) with the Firefox Profiler. It also features a comparison tool to look at profiling captures side by side.</li>
<li><a href="https://developer.chrome.com/docs/devtools/evaluate-performance/">Chrome DevTools Performance</a>: This web browser tool can be used to profile Unity Web builds.</li>
</ul>
<h2 id="-span-id-page-19-0-span-gpu-debugging-and-profiling-tools"><span id="page-19-0"></span>GPU debugging and profiling tools</h2>
<p>While the Unity Frame Debugger captures and illustrates draw calls that are sent from the CPU, the following tools can help show you what the GPU does when it receives those commands.</p>
<p>Some are platform-specific and offer closer platform integration. Here are some of the tools specifically available for various platforms:</p>
<ul>
<li><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/RenderDocIntegration.html?">RenderDoc</a>: GPU debugger for desktop and mobile platforms</li>
<li><a href="https://software.intel.com/content/www/us/en/develop/tools/graphics-performance-analyzers.html">Intel GPA</a>: Graphics profiling for Intel-based platforms</li>
<li><a href="https://developer.apple.com/documentation/metal/frame_capture_debugging_tools/">Apple Frame Capture Debugging Tools</a>: GPU debugging for Apple platforms</li>
<li><a href="https://docs.microsoft.com/en-gb/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2019&amp;redirectedfrom=MSDN&amp;viewFallbackFrom=vs-2015">Visual Studio Graphics Diagnostics:</a> Choose this and/or PIX for DirectX-based platforms such as Windows or Xbox</li>
<li><a href="https://developer.nvidia.com/nsight-graphics">NVIDIA Nsight Graphics:</a> Graphics profiler and debugger for NVIDIA GPUs.</li>
<li><a href="https://gpuopen.com/tools/">AMD Radeon Developer Tool Suite:</a> GPU profiler for AMD GPUs</li>
<li><a href="https://docs.unity3d.com/2020.1/Documentation/Manual/XcodeFrameDebuggerIntegration.html">Xcode frame debugger</a>: For iOS and macOS</li>
</ul>
<h3 id="project-auditor">Project Auditor</h3>
<p>The <a href="https://github.com/Unity-Technologies/ProjectAuditor">Project Auditor</a> is an experimental tool capable of performing static analysis of a project&#39;s scripts and settings. It offers a great way to track down the causes of managed memory allocations, inefficient project configurations, and possible performance bottlenecks.</p>
<p>The Project Auditor is a free, unofficial package for use with the Editor. For information, please refer to the <a href="https://github.com/Unity-Technologies/ProjectAuditor/blob/master/Documentation~/index.md">Project Auditor documentation.</a></p>
<h2 id="-span-id-page-20-0-span-memory"><span id="page-20-0"></span>Memory</h2>
<p>Unity employs automatic memory management for user-generated code and scripts. Small pieces of data, like value-typed local variables, are allocated to the stack. Larger pieces of data and long-term storage are allocated to the managed or native heaps.</p>
<p>The garbage collector periodically identifies and deallocates unused managed heap memory. The Asset garbage collection runs on demand or when you load a new scene, and it deallocates native objects and resources. While this runs automatically, the process of examining all the objects in the heap can cause the game to stutter or run slowly.</p>
<p>Optimizing your memory usage means being conscious of when you allocate and deallocate managed heap memory, and how you minimize the effect of garbage collection.</p>
<p>See <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/performance-memory-overview.html">Understanding the managed heap</a> for more information.</p>
<p><span id="page-21-0"></span><img src="_page_21_Figure_1.jpeg" alt=""></p>
<p>Capture, inspect, and compare snapshots in the Memory Profiler.</p>
<h2 id="use-the-memory-profiler">Use the Memory Profiler</h2>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.0/manual/index.html">Memory Profiler package</a> takes a snapshot of your managed heap memory to help you identify problems like fragmentation and memory leaks. For a quick introduction check out <a href="https://www.youtube.com/watch?v=Uuzd39AjFWQ&amp;t">this</a>  <a href="https://www.youtube.com/watch?v=Uuzd39AjFWQ&amp;t">Memory Profiler tutorial.</a></p>
<p>Use the <strong>Unity Objects</strong> tab to identify areas where you can eliminate duplicate memory entries or find which objects use the most memory. The <strong>All of Memory</strong> tab displays a breakdown of all the memory in the snapshot that Unity tracks.</p>
<p>Learn how to leverage the <a href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@latest">Memory Profiler in Unity</a> for improved memory usage.</p>
<h2 id="reduce-the-impact-of-garbage-collection-gc-">Reduce the impact of garbage collection (GC)</h2>
<p>Unity uses the <a href="https://www.hboehm.info/gc/">Boehm-Demers-Weiser garbage collector</a>, which stops running your program code and only resumes normal execution once its work is complete.</p>
<p>Be aware of certain unnecessary heap allocations, which could cause GC spikes:</p>
<p>— <strong>Strings:</strong> In C#, strings are reference types, not value types. This means that every new string will be allocated on the managed heap, even if it&#39;s only used temporarily. Reduce unnecessary string creation or manipulation if you are using them at large scale. Avoid parsing string-based data files such as JSON and XML, and store data in ScriptableObjects or formats like MessagePack or Protobuf instead. Use the <a href="https://msdn.microsoft.com/en-us/library/system.text.stringbuilder">StringBuilder</a> class if you need to build strings at runtime.</p>
<ul>
<li><span id="page-22-0"></span>— <strong>Unity function calls</strong>: Some Unity API functions create heap allocations, particularly ones which return an array of managed objects. Cache references to arrays rather than allocating them in the middle of a loop. Also, take advantage of certain functions that avoid generating garbage. For example, use <strong>GameObject.CompareTag</strong> instead of manually comparing a string with <strong>GameObject.tag</strong> (as returning a new string creates garbage).</li>
<li><strong>Boxing</strong>: Avoid passing a value-typed variable in place of a reference-typed variable. This creates a temporary object, and the potential garbage that comes with it implicitly converts the value type to a type object (e.g., <strong>int i = 123; object o = i</strong>). Instead, try to provide concrete overrides with the value type you want to pass in. Generics can also be used for these overrides.</li>
<li><strong>Coroutines</strong>: Though yield does not produce garbage, creating a new WaitForSeconds object does. Cache and reuse the WaitForSeconds object rather than creating it in the yield line.</li>
<li><strong>LINQ and Regular Expressions</strong>: Both of these generate garbage from behind-thescenes boxing. Avoid LINQ and Regular Expressions if performance is an issue. Write for loops and use lists as an alternative to creating new arrays.</li>
<li><strong>Generic Collections and other managed types</strong>: Don&#39;t declare and populate a List or collection every frame in Update (for example, a list of enemies within a certain radius of the player). Instead make the List a member of the MonoBehaviour and initialize it in Start. Simply empty the collection with Clear every frame before using it.</li>
</ul>
<p>For more information, see the manual page on <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/performance-garbage-collection-best-practices.html">Garbage Collection Best Practices</a>.</p>
<h4 id="time-garbage-collection-whenever-possible">Time garbage collection whenever possible</h4>
<p>If you are certain that a garbage collection freeze won&#39;t affect a specific point in your game, you can trigger garbage collection with <strong>System.GC.Collect</strong>.</p>
<p>See <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/performance-garbage-collector.html">Understanding Automatic Memory Management</a> for examples of how to use this to your advantage. 1</p>
<p><sup>1</sup> Note that using the GC can add read-write barriers to some C# calls, which come with little overhead that can add up to ~1 ms per frame of scripting call overhead. For optimal performance, it is ideal to have no GC Allocs in the main gameplay loops and to hide the GC.Collect where a user won&#39;t notice it.</p>
<h4 id="-span-id-page-23-0-span-use-the-incremental-garbage-collector-to-split-the-gc-workload"><span id="page-23-0"></span>Use the Incremental Garbage Collector to split the GC workload</h4>
<p>Rather than creating a single, long interruption during your program&#39;s execution, incremental garbage collection uses multiple, much shorter interruptions that distribute the workload over many frames. If garbage collection is impacting performance, try enabling this option to see if it can reduce the problem of GC spikes. Use the Profile Analyzer to verify its benefit to your application.</p>
<p><strong>Note:</strong> Incremental GC can temporarily help mitigate garbage collection issues, but the best long-term course of action is to locate and stop frequent allocations that trigger garbage collection.</p>
<table>
<thead>
<tr>
<th>Project Settings</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>ರ</td>
</tr>
<tr>
<td>Adaptive Performance</td>
<td>Player</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Audio<br>Burst AOT Settings</td>
<td>Version®</td>
<td>1.0</td>
<td></td>
</tr>
<tr>
<td>Editor</td>
<td>Bundle Version Code</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Graphics</td>
<td>Minimum API Level</td>
<td>Android 6.0 &#39;Marshmallow&#39; (API level 23)</td>
<td></td>
</tr>
<tr>
<td>Input Manager</td>
<td>Target API Level</td>
<td>Automatic (highest Installed)</td>
<td></td>
</tr>
<tr>
<td>Input System Package<br>Settings</td>
<td>Configuration</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Memory Settings</td>
<td>Scripting Backend</td>
<td>IL2CPP</td>
<td></td>
</tr>
<tr>
<td>Package Manager</td>
<td>Api Compatibility Level®</td>
<td>.NET Standard 2.1</td>
<td></td>
</tr>
<tr>
<td>v Physics<br>Settings</td>
<td>Editor Assemblies Compatibility Level®</td>
<td>Default (.NET Framework)</td>
<td></td>
</tr>
<tr>
<td>Physics 2D</td>
<td>IL2CPP Code Generation</td>
<td>Faster runtime</td>
<td></td>
</tr>
<tr>
<td>Player</td>
<td>C++ Compiler Configuration</td>
<td>Release</td>
<td></td>
</tr>
<tr>
<td>Preset Manager<br>Quality<br>Scene Template</td>
<td>IL2CPP Stacktrace Information</td>
<td>Method Name</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Use incremental GC</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Script Execution Order</td>
<td>Allow downloads over HTTP®</td>
<td>Not allowed</td>
<td></td>
</tr>
<tr>
<td>Services<br>ShaderGraph</td>
<td>Mute Other Audio Sources®</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tags and Layers</td>
<td>Target Architectures</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TextMesh Pro</td>
<td>ARMV7</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>Settings</td>
<td>ARM64</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>Time<br>Timeline</td>
<td>x86-64 (Magic Leap 2)</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>Ul Toolkit</td>
<td>Enable Armv9 Security Features for Arm6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Version Control<br>VEX</td>
<td>Split APKs by target architecture</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Install Location</td>
<td>Prefer External</td>
<td></td>
</tr>
<tr>
<td>Visual Scripting<br>XR Plugin Management</td>
<td>Internet Access<br>Write Permission</td>
<td>Auto<br>Internal</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Filter Touches When Obscured</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Use the Incremental Garbage Collector to reduce GC spikes.</p>
<h2 id="-span-id-page-24-0-span-assets"><span id="page-24-0"></span>Assets</h2>
<p>The asset pipeline can dramatically impact your application&#39;s performance. An experienced technical artist can help your team define and enforce asset formats, specifications, and import settings for smooth processes.</p>
<p>Don&#39;t rely on default settings. Use the platform-specific override tab to optimize assets such as textures and mesh geometry. Incorrect settings might yield larger build sizes, longer build times, poor GPU performance, and poor memory usage. Consider using the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Presets.html">Presets</a> feature to help customize baseline settings that will enhance a specific project.</p>
<p>See <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ImportingAssets.html">this guide to best practices for importing art assets.</a> For a mobile-specific guide (with many general tips as well), check out the Unity Learn course on <a href="https://learn.unity.com/course/3d-art-optimization-for-mobile-gaming-5474?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=console-pc-performance-optimization-ebook">3D art optimization for mobile</a>  <a href="https://learn.unity.com/course/3d-art-optimization-for-mobile-gaming-5474?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=console-pc-performance-optimization-ebook">applications.</a> And watch the GDC 2023 session <a href="https://youtu.be/o_QBMz0WZjI?list=PLX2vGYjWbI0TkxPwhWgsBhvj-EwxJDt5x&amp;t=656">&quot;Technical tips for every stage of game</a>  <a href="https://youtu.be/o_QBMz0WZjI?list=PLX2vGYjWbI0TkxPwhWgsBhvj-EwxJDt5x&amp;t=656">creation&quot;</a> to learn more about how to leverage Presets.</p>
<h4 id="compress-textures">Compress textures</h4>
<p>Consider these two examples using the same model and texture. The settings on the top consume more than five times the memory compared to those on the bottom, without much benefit in visual quality.</p>
<p><span id="page-25-0"></span><img src="_page_25_Picture_1.jpeg" alt=""></p>
<p>Uncompressed textures require more memory.</p>
<p><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-TextureImporter.html?">Texture compression</a> offers significant performance benefits when you apply it correctly.</p>
<p>This can result in faster load times, a smaller memory footprint, and dramatically increased rendering performance. Compressed textures only use a fraction of the memory bandwidth needed for uncompressed 32-bit RGBA textures.</p>
<p>Refer to this <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-TextureImporterOverride.html?">recommended list of texture compression formats</a> for your target platform:</p>
<ul>
<li><strong>iOS / Android /</strong>: Use <strong>ASTC</strong>.</li>
<li><strong>PC/XBox One/PlayStation®4</strong>: <strong>BC7</strong> (high quality) or <strong>DXT1</strong> (low/normal quality)</li>
</ul>
<h4 id="texture-import-settings">Texture import settings</h4>
<p>Textures can potentially use a lot of resources. Import settings here are critical. Try to follow these guidelines:</p>
<ul>
<li><strong>Lower the Max Size</strong>: Use the minimum settings that produce visually acceptable results. This is non-destructive and can quickly reduce your texture memory.</li>
<li><strong>Use powers of two (POT)</strong>: Unity requires POT texture dimensions for texture compression formats.</li>
<li><strong>Toggle off the Read/Write Enabled option</strong>: When enabled, this option creates a copy in both CPU- and GPU-addressable memory, doubling the texture&#39;s memory footprint. In</li>
</ul>
<p><span id="page-26-0"></span>most cases, keep this disabled (only enable this if you generate a texture at runtime and need to overwrite it). You can also enforce this option via <strong>Texture2D.Apply</strong>, passing in <strong>makeNoLongerReadable</strong> set to true.</p>
<p>— <strong>Disable unnecessary mipmaps</strong>: While mipmaps are used to optimize performance by reducing the amount of detail that needs to be rendered at different distances from the camera, they aren&#39;t always needed. For textures that remain at a consistent size on screen, such as 2D sprites and UI graphics (leave mipmap enabled for 3D models with varying distance from the camera) you can leave them out.</p>
<table>
<thead>
<tr>
<th>cene a Game</th>
<th></th>
<th>· Inspector · Project Settings<br>10</th>
<th></th>
<th>a !</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pivot · [Local · 1 · 1 · 2 ·</td>
<td>0 0 0 0 0 0 8 = 20 16 2 = 20 == 20 == 20 == 20 == 20 == 0 == 0 ==</td>
<td>Brass_Albedo (Texture 2D) Import Settings *</td>
<td></td>
<td>071 .</td>
</tr>
<tr>
<td>中 呈 榮 ○ 念 ○ 中 零</td>
<td></td>
<td>Texture Type<br>PA<br>Texture Shape</td>
<td>Default<br>2D</td>
<td>Open<br>V</td>
</tr>
<tr>
<td></td>
<td></td>
<td>sRGB (Color Texture)<br>&lt; Persp<br>Alpha Source<br>Alpha is Transparency</td>
<td>V<br>Input Texture Alpha</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Advanced<br>Non-Power of 2<br>Read/Write<br>Virtual Texture Only<br>Generate Mipmap<br>T Generation Settings</td>
<td>ToNearest<br>D<br>1<br>&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Mipmap Filtering<br>Preserve Coverage<br>Replicate Border<br>Fadeout to Gray<br>Mipmap Limit</td>
<td>Box<br>12 19<br>- 1<br>0<br>V</td>
<td></td>
</tr>
<tr>
<td>8000</td>
<td></td>
<td>Mipmap Limit Group<br>Stream Mipmap Levels<br>Ignore PNG Gamma<br>Swizzlo<br>1</td>
<td>None (Use Global Mipmap Limit)<br>RE<br>- G<br>TB<br>A</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Wrap Mode<br>Filter Mode<br>Aniso Level<br>G<br>Default</td>
<td>Repeat<br>Billnear<br>P<br>200<br>0</td>
<td>@</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Max Size</td>
<td>1024</td>
<td></td>
</tr>
<tr>
<td>SceneAssets &gt; Textures &gt; General</td>
<td>a</td>
<td>a R<br>Resize Algorithm<br>因為 # # # 27<br>Format</td>
<td>Mitchell<br>Automatic</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Compression<br>Use Crunch Compression<br>Brass_Albedo</td>
<td>Normal Quality<br>S<br>RGB R G B C</td>
<td></td>
</tr>
<tr>
<td>mboo A</td>
<td>Bamboo.A  Bamboo.A  Bamboo.A  Brass.Able. Brass.Mao  Brass.Nor  Bush.01.00.00.00.00.00</td>
<td>Bush_01_M</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Concretel. Concretat. Concretati. Concretabl. ConcreteM  ConcreteM  ConcreteM  Concretel</td>
<td></td>
<td>ConcreteP  ConcreteP</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>DIANSA MINISTRA<br>TO SUNTIONS (REMARY THE FORMER )</td>
</tr>
</tbody>
</table>
<p>Proper texture import settings will help optimize your build size.</p>
<h4 id="atlas-your-textures">Atlas your textures</h4>
<p>Atlasing is the process of grouping together several smaller textures into a single uniformly sized larger texture. This can reduce the GPU effort needed to draw the content (using fewer draw calls) and reduce memory usage.</p>
<p>For 2D projects, you can use a <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-SpriteAtlas.html">Sprite Atlas</a> (<strong>Asset &gt; Create &gt; 2D &gt; Sprite Atlas</strong>) rather than rendering individual Sprites and Textures.</p>
<p>For 3D projects, you can use your digital content creation (DCC) package of choice. Several third-party tools like <a href="https://maxkruf.com/ma_textureatlas/">MA\_TextureAtlasser</a> or <a href="https://www.codeandweb.com/texturepacker">TexturePacker</a> also can build texture atlases.</p>
<p><span id="page-27-0"></span><img src="_page_27_Picture_1.jpeg" alt=""></p>
<p>Use texture atlases to save draw calls.</p>
<p>Combine textures and remap UVs for any 3D geometry that doesn&#39;t require high-resolution maps. A visual editor gives you the ability to set and prioritize the sizes and positions in the texture atlas or sprite sheet.</p>
<p>The texture packer consolidates the individual maps into one large texture. Unity can then issue a single draw call to access the packed Textures with a smaller performance overhead.</p>
<h2 id="check-your-polygon-counts">Check your polygon counts</h2>
<p>Higher-resolution models mean more memory usage and potentially longer GPU times. Does your background geometry really need a million polygons?</p>
<p>Keep the geometric complexity of GameObjects in your scenes to a minimum, otherwise Unity has to push a lot of vertex data to the graphics card.</p>
<p>Consider cutting down models in your DCC package of choice. Delete unseen polygons from the camera&#39;s point of view. For example, if you never see the back of a cupboard resting against a wall, the model should not have any faces there.</p>
<p><img src="_page_28_Figure_1.jpeg" alt=""></p>
<p>Remove any unseen faces to optimize your models.</p>
<p>Be aware that the bottleneck is not usually polygon count on modern GPUs, but rather polygon density. We recommend performing an art pass across all assets to reduce the polygon count of distant objects. <a href="https://www.g-truc.net/post-0662.html">Microtriangles</a> can be a significant cause of poor GPU performance.</p>
<p>Depending on the target platform, investigate adding details via high-resolution textures to compensate for low-poly geometry. Use textures and normal maps instead of increasing the density of the mesh.</p>
<p>Reduce pixel complexity by baking as much detail into the textures as possible. For example, capture the specular highlights into the texture to avoid having to compute the highlight in the fragment shader.</p>
<p>Be mindful and remember to profile regularly, as these techniques can impact performance, and may not be suitable for your target platform.</p>
<p><span id="page-29-0"></span><img src="_page_29_Picture_0.jpeg" alt=""></p>
<h2 id="mesh-import-settings">Mesh import settings</h2>
<p>Much like textures, meshes can consume excess memory if not imported carefully. To minimize meshes&#39; memory consumption:</p>
<ul>
<li><strong>Use mesh compression</strong>: Aggressive mesh compression can reduce disk space (memory at runtime, however, is unaffected). Note that mesh quantization can result in inaccuracy, so experiment with compression levels to see what works for your models.</li>
<li><strong>Disable Read/Write</strong>: Enabling this option duplicates the mesh in memory, which keeps one copy of the mesh in system memory and another in GPU memory. In most cases, you should disable it (in Unity 2019.2 and earlier, this option is checked by default).</li>
<li><strong>Disable rigs and BlendShapes</strong>: If your mesh does not need skeletal or blendshape animation, disable these options wherever possible.</li>
<li><strong>Disable normals and tangents</strong>: If you are absolutely certain the mesh&#39;s material will not need normals or tangents, uncheck these options for extra savings.</li>
</ul>
<p><img src="_page_29_Picture_8.jpeg" alt=""></p>
<p>Check your mesh import settings.</p>
<h2 id="other-mesh-optimizations">Other mesh optimizations</h2>
<p>In the Player Settings, you can also apply a couple of other optimization to your meshes:</p>
<p>— <strong>Vertex Compression sets</strong> vertex compression per channel. For example, you can enable compression for everything except positions and lightmap UVs. This can reduce runtime memory usage from your meshes.</p>
<p><span id="page-30-0"></span><img src="_page_30_Picture_0.jpeg" alt=""></p>
<p>Note that the Mesh Compression in each mesh&#39;s Import Settings overrides the vertex compression setting. In that event, the runtime copy of the mesh is uncompressed and may use more memory.</p>
<p>— <strong>Optimize Mesh Data</strong> removes any data from meshes that is not required by the material applied to them (such as tangents, normals, colors, and UVs).</p>
<h4 id="audit-your-assets">Audit your assets</h4>
<p>By automating the Asset audit process, you can avoid accidentally changing asset settings. A couple tools can help both to standardize your import settings or analyze your existing assets.</p>
<h4 id="-the-assetpostprocessor-"><strong>The AssetPostprocessor</strong></h4>
<p>The <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/AssetPostprocessor.html?">AssetPostprocessor</a> allows you to hook into the import pipeline and run scripts prior to or when importing assets. This prompts you to customize settings before and/or after importing models, textures, audio, and so on in a way that&#39;s similar to presets but through code. Learn more about the process in the GDC 2023 talk &quot;<a href="https://youtu.be/o_QBMz0WZjI?list=PLX2vGYjWbI0TkxPwhWgsBhvj-EwxJDt5x&amp;t=816">Technical tips for every stage of game</a>  <a href="https://youtu.be/o_QBMz0WZjI?list=PLX2vGYjWbI0TkxPwhWgsBhvj-EwxJDt5x&amp;t=816">creation</a>.&quot;</p>
<h4 id="-unitydatatools-"><strong>UnityDataTools</strong></h4>
<p><a href="https://github.com/Unity-Technologies/UnityDataTools">UnityDataTools</a> is a collection of open source tools provided by Unity that aim to enhance the data management and serialization capabilities in Unity projects. It includes features for analyzing and optimizing project data, such as identifying unused assets, detecting asset dependencies, and reducing build size.</p>
<p>Learn more about the tools <a href="https://github.com/Unity-Technologies/UnityDataTools">here</a> and read more about <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/UnderstandingPerformanceAssetAuditing.html">Asset Auditing</a> in the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/UnderstandingPerformance.html">Understanding</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/UnderstandingPerformance.html">Optimization in Unity</a> section of the best practice guide.</p>
<h4 id="async-texture-buffer">Async texture buffer</h4>
<p>Unity uses a ring buffer to push textures to the GPU. You can manually adjust this async texture buffer via <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/QualitySettings-asyncUploadBufferSize.html">QualitySettings.asyncUploadBufferSize</a>.</p>
<p>If either the upload rate is too slow or the main thread stalls while loading several Textures at once, adjust the Texture <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/QualitySettings-asyncUploadBufferSize.html?">buffers</a>. Usually you can set the value (in MB) to the size of the largest texture you need to load in the Scene.</p>
<p><strong>Note:</strong> Be aware that changing the default values can lead to high memory pressure. Also, you cannot return ring buffer memory to the system after Unity allocates it. If GPU memory overloads, the GPU unloads the least-recently used Texture and forces the CPU to reupload it the next time it enters the camera frustum.</p>
<p>Read more about memory restrictions in Texture buffers when using time-slice awake in the <a href="https://unity3d.com/learn/tutorials/topics/best-practices/guide-optimizing-memory?playlist=30089?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=console-pc-performance-optimization-ebook">Memory Management in Unity</a> guide.</p>
<h3 id="-span-id-page-31-0-span-stream-mipmaps-and-textures"><span id="page-31-0"></span>Stream mipmaps and textures</h3>
<p>The <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/TextureStreaming.html">mipmap streaming system</a> gives you control over which mipmap levels load into memory. To enable it, go to Unity&#39;s Quality Settings (<strong>Edit &gt; Project Settings &gt; Quality</strong>) and check <strong>Texture Streaming</strong>. Enable <strong>Streaming Mipmaps</strong> in the texture&#39;s Import Settings under <strong>Advanced</strong>.</p>
<table>
<thead>
<tr>
<th>O<br>●</th>
<th>Project Settings</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Project Settings</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Q</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Adaptive Performance<br>Audio<br>Editor</td>
<td>Quality</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Graphics</td>
<td>Rendering</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Input Manager</td>
<td>G 3DCharacterUl-RP-Asset (Universal Render Pipeline Asset)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Package Manager</td>
<td>Texture Quality</td>
<td>Full Res</td>
<td></td>
<td>&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Physics<br>Physics 2D</td>
<td>Anisotropic Textures</td>
<td>Forced On</td>
<td></td>
<td>D</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Player</td>
<td>Realtime Reflection Probes</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Preset Manager</td>
<td>Billboards Face Camera Position</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Quality</td>
<td>Resolution Scaling Fixed DPI Factor</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Scene Template</td>
<td>Texture Streaming</td>
<td>B</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Script Execution Order<br>Services</td>
<td>Add All Cameras</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ads</td>
<td>Memory Budget</td>
<td>512</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Analytics</td>
<td>Renderers Per Frame</td>
<td>512</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cloud Build</td>
<td>Max Level Reduction</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cloud Diagnostics<br>Collaborate</td>
<td>Max IO Requests</td>
<td>1024</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>In-App Purchasing</td>
<td>Shadows</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tags and Layers<br>TextMesh Pro</td>
<td>Shadowmask Mode</td>
<td>Distance Shadowmask</td>
<td></td>
<td>▶</td>
<td></td>
</tr>
</tbody>
</table>
<p>Texture Streaming settings</p>
<table>
<thead>
<tr>
<th>Inspector</th>
<th></th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>sRGB (Color Texture)</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td>Alpha Source</td>
<td>Input Texture Alpha</td>
<td>V</td>
</tr>
<tr>
<td>Alpha Is Transparency</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ignore PNG file gamma</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Advanced</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Non-Power of 2</td>
<td>ToNearest</td>
<td>P</td>
</tr>
<tr>
<td>Read/Write Enabled</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Streaming Mipmaps</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Mip Map Priority</td>
<td>O</td>
<td></td>
</tr>
<tr>
<td>Virtual Texture Only</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Generate Mip Maps</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Border Mip Maps</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mip Map Filtering</td>
<td>Box</td>
<td>D</td>
</tr>
<tr>
<td>Mip Maps Preserve Coverage</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fadeout Mip Maps</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Wrap Mode</td>
<td>Repeat</td>
<td>V</td>
</tr>
<tr>
<td>Filter Mode</td>
<td>Bilinear</td>
<td>&gt;</td>
</tr>
<tr>
<td>Aniso Level</td>
<td></td>
</tr>
</tbody>
</table>
<p>Streaming Mipmaps is enabled.</p>
<p><span id="page-32-0"></span><img src="_page_32_Picture_0.jpeg" alt=""></p>
<p>This system reduces the total amount of memory needed for textures because it only loads the mipmaps necessary to render the current Camera position. Otherwise, Unity loads all of the textures by default. Texture streaming trades a small amount of CPU resources to save a potentially large amount of GPU memory.</p>
<p>You can use the <a href="https://docs.unity3d.com/Manual/TextureStreaming-API.html">Mipmap Streaming API</a> for additional control. Texture streaming automatically reduces mipmap levels to stay within the user-defined memory budget.</p>
<h2 id="use-addressables">Use Addressables</h2>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.addressables@2.2/manual/index.html">Addressable Asset System</a> simplifies how you manage the assets that make up your game. Any asset, including scenes, prefabs, text assets, and so on, can be marked as &quot;addressable&quot; and given a unique name. You can then call this alias from anywhere.</p>
<p>Titles being developed for platforms that include standalone and consoles should consider reviewing the following default settings on Addressable Asset Groups:</p>
<ul>
<li>AssetBundle Compression set to LZ4 is unnecessary on consoles (the filesystem has its own better compression) and also prevents efficient patching of small changes within a large bundle. Consider setting this to Uncompressed on console platforms and to LZ4 on Windows.</li>
<li>AssetBundle CRC set to Enabled, Including Caching on console platforms will significantly increase load times unnecessarily. This setting should be set to Disabled on console platforms where the local filesystem can be trusted. Consider setting this to Enabled, Including Caching on Windows if file tampering is considered to be an issue.</li>
<li>The Bundle Naming Mode setting is set to Append Hash to Filename works against consoles&#39; patching systems, which do not recognize a rename to &quot;the same&quot; file. Console platforms should have this setting set to Filename.</li>
</ul>
<p>Adding this extra level of abstraction between the game and its assets can streamline certain tasks, such as creating a separate downloadable content pack. Addressables makes referencing those asset packs easier as well, whether they&#39;re local or remote.</p>
<table>
<thead>
<tr>
<th>THE</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Addressables Groups</td>
<td></td>
</tr>
<tr>
<td>Addressables Groups</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Create . Profile: Default . Tools .</td>
<td></td>
<td>Play Mode Script · Build · &amp;</td>
</tr>
<tr>
<td>Group Name \ Addressable Name<br>Built In Data<br>v Inventory Items (Default)<br>Assets/Weapons/Prefabs/BossSword.prefab<br>Assets/Weapons/Prefabs/Shield.prefab<br>Assets/Weapons/Prefabs/Sword.prefab</td>
<td>ి Path<br>Assets/Weapons/Prefabs/BossSword.prefab<br>ଜି<br>Assets /Weapons/Prefabs/Shield.prefab<br>G<br>Assets/Weapons/Prefabs/Sword.prefab</td>
<td>Labels<br>&gt;<br>&gt;<br>&gt;</td>
</tr>
</tbody>
</table>
<p>In this example, Addressables tracks the inventory of prefabs.</p>
<p>Install the <a href="https://docs.unity3d.com/Packages/com.unity.addressables@2.2/manual/index.html">Addressables package</a> from the Package Manager. Each asset or prefab in the project has the ability to become &quot;addressable&quot; as a result. Checking the option under an asset&#39;s name in the Inspector assigns it a default unique address.</p>
<p><img src="_page_33_Picture_4.jpeg" alt=""></p>
<p>Addressable option enabled with default Addressable Name</p>
<p>Once marked, the corresponding assets appear in the <strong>Window &gt; Asset Management &gt; Addressables &gt; Groups</strong> window.</p>
<table>
<thead>
<tr>
<th># Scene</th>
<th>Co Profiler</th>
<th>Memory Profiler</th>
<th>Addressables Groups</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Create ▼ Profile: Default ▼ Tools▼</td>
<td></td>
<td></td>
<td>Play Mode Script ▼ Build ▼</td>
<td>0-</td>
</tr>
<tr>
<td></td>
<td>Group Name \ Addressable Name</td>
<td></td>
<td>Path</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Built In Data</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>T Inventory Items (Default)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Assets/Weapons/Prefabs/BossSword.prefab</td>
<td>T</td>
<td></td>
<td>Assets/Weapons/Prefabs/BossSword.prefab</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Assets/Weapons/Prefabs/Shield.prefab</td>
<td>7</td>
<td>Assets/Weapons/Prefabs/Shield.prefab</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Assets/Weapons/Prefabs/Sword.prefab</td>
<td>B</td>
<td>Assets/Weapons/Prefabs/Sword.prefab</td>
</tr>
</tbody>
</table>
<p>In the Addressables Groups, you can see each asset&#39;s custom address paired with its location.</p>
<p><img src="_page_34_Picture_0.jpeg" alt=""></p>
<p>Whether the asset is hosted elsewhere or stored locally, the system will locate it using the Addressable Name string. An addressable prefab does not load into memory until needed and automatically unloads its associated assets when no longer in use.</p>
<p>Two helpful blog posts to read on Addressables are:</p>
<ul>
<li><a href="https://blogs.unity3d.com/2021/03/31/tales-from-the-optimization-trenches-saving-memory-with-addressables/?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=console-pc-performance-optimization-ebook">Tales from the optimization trenches: Saving memory with Addressables</a> which demonstrates an example of how to organize your Addressable Groups in order to be more efficient with memory.</li>
<li><a href="https://unity.com/blog/engine-platform/addressables-planning-and-best-practices">Addressables: Planning and best practices</a> which provides tips for organizing, building, loading, and unloading addressable assets.</li>
</ul>
<h2 id="-span-id-page-35-0-span-programming-and-code-architecture"><span id="page-35-0"></span>Programming and code architecture</h2>
<p>The Unity <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/LowLevel.PlayerLoop.html?">PlayerLoop</a> contains functions for interacting with the core of the game engine. This structure includes a number of systems that handle initialization and per-frame updates. All of your scripts will rely on this PlayerLoop to create gameplay.</p>
<p>When profiling, you&#39;ll see your project&#39;s user code under the PlayerLoop (with Editor components under the EditorLoop).</p>
<p><img src="_page_35_Figure_3.jpeg" alt=""></p>
<p>The Profiler will show your custom scripts, settings, and graphics in the context of the entire engine&#39;s execution.</p>
<h2 id="understand-the-unity-playerloop">Understand the Unity PlayerLoop</h2>
<p>Make sure you understand the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ExecutionOrder.html">execution order</a> of Unity&#39;s frame loop. Every Unity script runs several event functions in a predetermined order. You should understand the difference between <strong>Awake</strong>, <strong>Start</strong>, <strong>Update</strong>, and other functions that create the lifecycle of a script. You can utilize the Low-Level API to add custom logic to the player&#39;s update loop.</p>
<p><img src="_page_36_Figure_1.jpeg" alt=""></p>
<p>Get to know the PlayerLoop and the <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html?">lifecycle of a script.</a></p>
<p><span id="page-37-0"></span><img src="_page_37_Picture_0.jpeg" alt=""></p>
<h4 id="minimize-code-that-runs-every-frame">Minimize code that runs every frame</h4>
<p>Consider whether code must run every frame. Move unnecessary logic out of Update, LateUpdate, and FixedUpdate. These event functions are convenient places to put code that must update every frame, while extracting any logic that does not need to update with that frequency. Whenever possible, only execute logic when things change.</p>
<p>If you do need to use <strong>Update</strong>, consider running the code every <em>n</em> frames. This is one way to apply time slicing, a common technique of distributing a heavy workload across multiple frames. In this example, we run the <strong>ExampleExpensiveFunction</strong> once every three frames:</p>
<p><img src="_page_37_Figure_5.jpeg" alt=""></p>
<p>Better yet, if <strong>ExampleExpensiveFunction</strong> performs some operation on a set of data, consider using time slicing to operate on a different subset of that data every frame. By doing 1/<em>n</em> of the work every frame rather than all of the work every n frames, you end up with performance that is more stable and predictable overall, rather than seeing periodic CPU spikes.</p>
<p>The trick is to interleave this with other work that runs on the other frames. In this example, you could &quot;schedule&quot; other expensive functions when <strong>Time.frameCount % interval == 1</strong> or <strong>Time.frameCount % interval == 2</strong>.</p>
<p>Alternatively, use a custom UpdateManager class (below) and update subscribed objects every n frames.</p>
<h4 id="-avoid-heavy-logic-in-start-awake-"><strong>Avoid heavy logic in Start/Awake</strong></h4>
<p>When your first scene loads, these functions get called for each object:</p>
<ul>
<li><strong>Awake</strong></li>
<li><strong>OnEnable/OnDisable</strong></li>
<li><strong>Start</strong></li>
</ul>
<p>Avoid expensive logic in these functions until your application renders its first frame. Otherwise, you might encounter longer loading times than necessary.</p>
<p>Refer to the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ExecutionOrder.html?">order of execution for event functions</a> for more details on the first scene load.</p>
<p><span id="page-38-0"></span><img src="_page_38_Picture_0.jpeg" alt=""></p>
<h3 id="cache-the-results-of-expensive-functions">Cache the results of expensive functions</h3>
<p>It&#39;s generally best to cache references in either Awake or Start in order to avoid calling them in the Update method.</p>
<p>Frequently calling these methods can contribute to CPU spikes. Wherever possible, run expensive functions in the initialization phase (i.e., <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MonoBehaviour.Awake.html">MonoBehaviour.Awake</a> and <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MonoBehaviour.Start.html">MonoBehaviour.</a> <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MonoBehaviour.Start.html">Start</a>). Cache the needed references and reuse them later.</p>
<p>Here&#39;s an example that demonstrates inefficient use of a repeated GetComponent call:</p>
<p><img src="_page_38_Figure_6.jpeg" alt=""></p>
<p>Instead, invoke <strong>GetComponent</strong> only once, as the result of the function is cached. The cached result can be reused in <strong>Update</strong> without any further calls to <strong>GetComponent</strong>.</p>
<pre><code><span class="hljs-keyword">private</span> Renderer myRenderer;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span>
</span>{
 myRenderer = GetComponent&lt;Renderer&gt;();
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span>
</span>{
 ExampleFunction(myRenderer);
}
</code></pre><p>In Unity versions prior to Unity 2020.2 <strong>GameObject.Find, GameObject.GetComponent</strong>, and <strong>Camera.main</strong> used to be very expensive, however this is no longer the case. That said, it&#39;s best to avoid calling them in <strong>Update</strong> methods and follow the practice above by caching the results.</p>
<p><span id="page-39-0"></span><img src="_page_39_Picture_0.jpeg" alt=""></p>
<h2 id="avoid-empty-unity-event-functions">Avoid empty Unity event functions</h2>
<p>Even empty MonoBehaviours require resources, so you should remove blank Update or LateUpdate methods.</p>
<p>Use preprocessor directives if you are employing these methods for testing:</p>
<p><img src="_page_39_Picture_5.jpeg" alt=""></p>
<p>Here, you can freely use the Update in-Editor for testing without unnecessary overhead slipping into your build.</p>
<h4 id="build-a-custom-update-manager">Build a custom Update Manager</h4>
<p>A common usage pattern for Update or LateUpdate is to run logic only when some condition is met. This can lead to a lot of per-frame callbacks that effectively run no code except for checking this condition.</p>
<p>Everytime Unity calls a Message method like Update or LateUpdate, it makes an <strong>interop call</strong>, a call from the C/C++ side to the managed C# side. For a small number of objects, this is not an issue. When you have thousands of objects, this overhead starts becoming significant.</p>
<p>Consider creating a custom UpdateManager if you have a large project using Update or LateUpdate in this fashion (e.g. an open-world game). Have active objects subscribe to this UpdateManager when they want callbacks, and unsubscribe when they don&#39;t. This pattern could reduce many of the interop calls to your Monobehaviour objects.</p>
<p><span id="page-40-0"></span><img src="_page_40_Figure_1.jpeg" alt=""></p>
<p>Refer to <a href="https://github.com/Menyus777/Game-engine-specific-optimization-techniques-for-Unity">Game engine-specific optimization techniques for Unity</a> for an example of implementation and potential performance gains.</p>
<h2 id="remove-debug-log-statements">Remove Debug Log statements</h2>
<p>Log statements (especially in Update, LateUpdate, or FixedUpdate) can bog down performance. Disable your Log statements before making a build.</p>
<p>To do this more easily, consider making a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.conditionalattribute?view=net-5.0">Conditional attribute</a> along with a preprocessing directive. For example, create a custom class like this:</p>
<p><img src="_page_40_Figure_6.jpeg" alt=""></p>
<p><span id="page-41-0"></span><img src="_page_41_Picture_0.jpeg" alt=""></p>
<p><img src="_page_41_Picture_2.jpeg" alt=""></p>
<p>Adding a custom preprocessor directive lets you partition your scripts.</p>
<p>Generate your log message with your custom class. If you disable the <strong>ENABLE_LOG</strong> preprocessor in the <strong>Player Settings &gt; Scripting Define Symbols</strong>, all of your Log statements disappear in one fell swoop.</p>
<p>The same thing applies for other use cases of the Debug Class, such as Debug.DrawLine and Debug.DrawRay. These are also only intended for use during development and can significantly impact performance.</p>
<p>Handling strings and text is a common source of performance problems in Unity projects. Removing Log statements – and their expensive string formatting – can be a huge win.</p>
<h4 id="disable-stack-trace-logging">Disable Stack Trace logging</h4>
<p>Use the Stack Trace options in the Player Settings to control what type of log messages appear.</p>
<p>If your application is logging errors or warning messages in your release build (e.g., to generate crash reports in the wild), disable stack traces to improve performance.</p>
<table>
<thead>
<tr>
<th>Stack Trace*</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Log Type</td>
<td>None</td>
<td>ScriptOnly</td>
<td>Full</td>
</tr>
<tr>
<td>Error</td>
<td>0</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Assert</td>
<td>D</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Warning</td>
<td></td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Log</td>
<td></td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Exception</td>
<td>0</td>
<td>&gt;</td>
</tr>
</tbody>
</table>
<p>Stack Trace options</p>
<h4 id="use-hash-values-instead-of-string-parameters">Use hash values instead of string parameters</h4>
<p>Unity does not use string names to address animator, material, and shader properties internally. For speed, all property names are hashed into property IDs, and these IDs are actually used to address the properties.</p>
<p>When using a Set or Get method on an animator, material, or shader, harness the integervalued method instead of the string-valued methods. The string methods simply perform string hashing and then forward the hashed ID to the integer-valued methods.</p>
<p><span id="page-42-0"></span><img src="_page_42_Picture_0.jpeg" alt=""></p>
<p>Use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Animator.StringToHash.html?">Animator.StringToHash</a> for Animator property names and <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Shader.PropertyToID.html">Shader.PropertyToID</a> for material and shader property names. Get these hashes during initialization and cache them in variables for when they&#39;re needed to pass to a Get or Set method.</p>
<h4 id="choose-the-right-data-structure">Choose the right data structure</h4>
<p>Your choice of data structure impacts efficiency as you iterate thousands of times per frame. Not sure whether to use a list, array, or dictionary for your collection? Follow the <a href="https://msdn.microsoft.com/en-us/library/7y3x785f">MSDN guide</a>  <a href="https://msdn.microsoft.com/en-us/library/7y3x785f">to data structures</a> in C# as a general guide for choosing the correct structure.</p>
<h4 id="avoid-adding-components-at-runtime">Avoid adding components at runtime</h4>
<p>Invoking AddComponent at runtime comes with some cost. Unity must check for duplicates or other required components whenever adding components at runtime.</p>
<p><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Prefabs.html">Instantiating a prefab</a> with the desired components already set up is generally more performant.</p>
<h3 id="use-object-pools">Use object pools</h3>
<p>Instantiate and Destroy can generate garbage and garbage collection (GC) spikes, a generally slow process. Apply object pooling techniques when you need to instantiate a large number of objects to help avoid GC spikes.</p>
<p><img src="_page_42_Picture_10.jpeg" alt=""></p>
<p>In this example, the ObjectPool creates 20 PlayerLaser instances for reuse.</p>
<p>Object pooling is a design pattern that can provide performance optimization by reducing the processing power required of the CPU to run repetitive create and destroy calls. Instead, with object pooling, existing GameObjects can be reused over and over.</p>
<p>The key function of object pooling is to create objects in advance and store them in a pool, rather than have them created and destroyed on demand. When an object is needed, it&#39;s taken from the pool and used. When it&#39;s no longer needed, it&#39;s returned to the pool rather than being destroyed.</p>
<p>Rather than regularly instantiating and destroying GameObjects (e.g., shooting bullets from a gun), use <a href="https://en.wikipedia.org/wiki/Object_pool_pattern">pools</a> of preallocated objects that can be reused and recycled.</p>
<p><span id="page-43-0"></span><img src="_page_43_Figure_1.jpeg" alt=""></p>
<p>This reduces the number of managed allocations in your project and can prevent garbage collection problems.</p>
<p>Unity includes a built-in object pooling feature via the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Pool.ObjectPool_1.html">UnityEngine.Pool</a> namespace. Available in Unity 2021 LTS and later, this namespace facilitates the management of object pools, automating aspects like object lifecycle and pool size control.</p>
<p>Learn how to create a simple object pooling system in Unity <a href="https://learn.unity.com/tutorial/introduction-to-object-pooling">here</a>. You can also see the object pooling pattern, and many others, implemented in a Unity scene <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/level-up-your-code-with-design-patterns-and-solid-289616">in this sample project</a>  <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/level-up-your-code-with-design-patterns-and-solid-289616">available on the Unity Asset Store.</a></p>
<h4 id="transform-once-not-twice">Transform once, not twice</h4>
<p>When moving Transforms, use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Transform.SetPositionAndRotation.html?">Transform.SetPositionAndRotation</a> to update both position and rotation at once. This avoids the overhead of modifying a transform twice.</p>
<p>If you need to <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Object.Instantiate.html?">Instantiate</a> a GameObject at runtime, a simple optimization is to parent and reposition during instantiation:</p>
<pre><code>GameObject.<span class="hljs-keyword">Instantiate(prefab, </span>parent)<span class="hljs-comment">;</span>
GameObject.<span class="hljs-keyword">Instantiate(prefab, </span>parent, position, rotation)<span class="hljs-comment">;</span>
</code></pre><p>For more on Object.Instantiate, please see the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Object.Instantiate.html?">Scripting API.</a></p>
<p><span id="page-44-0"></span><img src="_page_44_Picture_0.jpeg" alt=""></p>
<h2 id="use-scriptableobjects">Use ScriptableObjects</h2>
<p>Store static unchanging values or settings in a ScriptableObject instead of a MonoBehaviour. The ScriptableObject is an asset that lives inside of the project that you only need to set up once.</p>
<p>MonoBehaviours carry extra overhead since they require a GameObject – and by default a Transform – to act as a host. That means that you need to create a lot of unused data before storing a single value. The ScriptableObject slims down this memory footprint by dropping the GameObject and Transform. It also stores the data at the project level, which is helpful if you need to access the same data from multiple scenes.</p>
<p>A common use case is having many GameObjects that rely on the same duplicate data, which does not need to change at runtime. Rather than having this duplicate local data on each GameObject, you can funnel it into a ScriptableObject. Then, each of the objects stores a reference to the shared data asset, rather than copying the data itself. This is a benefit that can provide significant performance improvements in projects with thousands of objects.</p>
<p><img src="_page_44_Figure_6.jpeg" alt=""></p>
<p>Create fields in the ScriptableObject to store your values or settings, then reference the ScriptableObject in your MonoBehaviours.</p>
<p>In this example, a ScriptableObject called Inventory holds settings for various GameObjects.</p>
<p>Using fields from the ScriptableObject can prevent unnecessary duplication of data every time you instantiate an object with that MonoBehaviour.</p>
<p>In software design, this is an optimization known as the flyweight pattern. Restructuring your code in this way using ScriptableObjects avoids copying a lot of values and reduces your memory footprint. Learn more about the flyweight pattern and many others, as well as design principles in the e-book <em><a href="https://unity.com/resources/design-patterns-solid-ebook?isGated=alse">Level up your code with design patterns and SOLID</a></em>.</p>
<p><span id="page-45-0"></span><img src="_page_45_Picture_0.jpeg" alt=""></p>
<p>Watch this <a href="https://youtu.be/WLDgtRNK2VE">Introduction to ScriptableObjects</a> tutorial to see how ScriptableObjects can benefit your project. Reference Unity documentation <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-scriptableobject.html">here</a> as well as the technical guide <em><a href="https://unity.com/resources/create-modular-game-architecture-with-scriptable-objects-ebook?isGated=false">Create</a>  <a href="https://unity.com/resources/create-modular-game-architecture-with-scriptable-objects-ebook?isGated=false">modular game architecture in Unity with ScriptableObjects</a></em>.</p>
<h4 id="avoid-lambda-expressions">Avoid lambda expressions</h4>
<p>A lambda expression can simplify your code, but that simplification comes at a cost. Calling a lambda creates a delegate as well. Passing context (e.g., this, an instance member, or a local variable) into the lambda invalidates any caching for the delegate. When that happens, invoking it frequently can generate significant memory traffic.</p>
<p>Refactor any methods containing closures while using lambda expressions. See an example of how to do that <a href="https://blog.jetbrains.com/dotnet/2014/07/24/unusual-ways-of-boosting-up-app-performance-lambdas-and-linqs/">here</a>.</p>
<h3 id="the-c-job-system">The C# job system</h3>
<p>Modern CPUs have multiple cores, but your application needs multithreaded code to take advantage of them. Unity&#39;s job system allows you to split large tasks into smaller chunks that run in parallel on those extra CPU cores, which can improve performance significantly.</p>
<p>Often in multithreaded programming, one CPU thread of execution, the main thread, creates other threads to handle tasks. These additional worker threads then synchronize with the main thread once their work completes.</p>
<p><img src="_page_45_Figure_9.jpeg" alt=""></p>
<p>In traditional multithreaded programming, threads are created and destroyed. In the C# job system, small jobs run on a pool of threads.</p>
<p>If you have a few tasks that run for a long time, this approach to multithreading works well. However, it&#39;s less efficient for a game application, which must typically process many short tasks at 30–60 frames per second.</p>
<p>That&#39;s why Unity uses a slightly different approach to multithreading called the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/JobSystem.html?">C# job system.</a> Rather than generate many threads with a short lifetime, it breaks your work into smaller units called <strong>jobs</strong>.</p>
<p><img src="_page_46_Figure_3.jpeg" alt=""></p>
<p>Timeline view in the Profiler shows jobs running on the worker threads.</p>
<p>These jobs go into a <a href="https://en.wikipedia.org/wiki/Job_queue">queue,</a> which schedules them to run on a shared pool of <a href="https://docs.microsoft.com/en-us/cpp/parallel/multithreading-creating-worker-threads?view=msvc-160">worker threads.</a> <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/JobSystemJobDependencies.html?">JobHandles</a> help you create dependencies, ensuring that the jobs run in the correct order.</p>
<p>One potential issue with multithreading is a <a href="https://en.wikipedia.org/wiki/Race_condition">race condition,</a> which occurs when two threads access a shared variable at the same time. To prevent this, Unity multithreading uses a safety system to isolate the data a job needs to execute. The C# job system launches each job with a copy of the job structure, eliminating race conditions.</p>
<p>To use Unity&#39;s C# job system, follow these guidelines:</p>
<p>— Change classes to be structs. A job is any struct that implements the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/JobSystemCreatingJobs.html?">IJob</a> interface. If you&#39;re performing the same task on a large number of objects, you could also use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Unity.Jobs.IJobParallelFor.html?">IJobParallelFor</a> to run across multiple cores.</p>
<p><span id="page-47-0"></span><img src="_page_47_Picture_0.jpeg" alt=""></p>
<ul>
<li>Data passed into a job must be <a href="https://en.wikipedia.org/wiki/Blittable_types">blittable.</a> Remove reference types and pass only the blittable data into the job as a copy.</li>
<li>Because the work within each job remains isolated for safety, you send the results back to the main thread using a <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/JobSystemNativeContainer.html?">NativeContainer</a>. A NativeContainer from the <a href="https://docs.unity3d.com/Packages/com.unity.collections@2.5/manual/index.html">Unity Collections</a>  <a href="https://docs.unity3d.com/Packages/com.unity.collections@2.5/manual/index.html">package</a> provides a C# wrapper for native memory. Its subtypes (e.g., NativeArray, NativeList, NativeHashMap, NativeQueue, etc.) work like their equivalent C# data structures.</li>
</ul>
<p>Refer to the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/JobSystem.html">documentation</a> to see how you can optimize CPU performance in your own project using the C# job system.</p>
<h4 id="the-burst-compiler">The Burst compiler</h4>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/index.html">Burst compiler</a> complements the Job System. Burst translates IL/.NET bytecode into optimized native code using <a href="https://llvm.org/">LLVM</a>. To access it, simply add the <strong>com.unity.burst</strong> package from the Package Manager.</p>
<p>Burst allows Unity developers to continue using a subset of C# for convenience while improving performance.</p>
<p>To enable the Burst compiler for your scripts:</p>
<ul>
<li>Remove static variables. If you need to write to a list, consider using a NativeArray decorated with the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeDisableContainerSafetyRestrictionAttribute.html?">NativeDisableContainerSafetyRestriction attribute</a>. This allows parallel jobs to write to the NativeArray.</li>
<li>Use <a href="https://docs.unity3d.com/Packages/com.unity.mathematics@latest?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-multiplatform&amp;utm_content=optimize-game-performance-2020-lts-ebook">Unity.Mathematics</a> functions instead Mathf. functions.</li>
<li>Decorate the job definition with the <a href="https://docs.unity3d.com/Packages/com.unity.burst@1.1/api/Unity.Burst.BurstCompileAttribute.html?">BurstCompile attribute</a>.</li>
</ul>
<pre><code> [BurstCompile]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> MyFirstJob : IJob
{
     <span class="hljs-keyword">public</span> NativeArray&lt;float3&gt; ToNormalize;
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span>
      </span>{
 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ToNormalize.Length; i++)
 {
 ToNormalize[i] = math.normalize(ToNormalize[i]);
 }
     }
}
</code></pre><p><img src="_page_48_Picture_0.jpeg" alt=""></p>
<p>Here is an example Burst job that runs over an array of float3&#39;s and normalizes the vectors. It uses the <a href="https://docs.unity3d.com/Packages/com.unity.mathematics@latest?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-multiplatform&amp;utm_content=optimize-game-performance-2020-lts-ebook">Unity Mathematics</a> package, as mentioned above.</p>
<p>Both the C# job system and the Burst compiler form part of Unity&#39;s <a href="https://unity.com/dots">Data-Oriented Tech Stack</a>  <a href="https://unity.com/dots">(DOTS).</a> However, you can use them with both &quot;classic&quot; Unity GameObjects or the <a href="https://docs.unity3d.com/Packages/com.unity.entities@0.17/manual/index.html">Entity</a>  <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.3/manual/index.html">Component System.</a></p>
<p>Refer to the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/com.unity.burst.html">latest documentation</a> and download the e-book <em><a href="https://unity.com/resources/introduction-to-dots-ebook">Introduction to the Data-Oriented</a>  <a href="https://unity.com/resources/introduction-to-dots-ebook">Technology Stack for advanced Unity users</a></em> to see how Burst can accelerate your workflow when combined with the C# job system.</p>
<h2 id="-span-id-page-49-0-span-project-configuration"><span id="page-49-0"></span>Project configuration</h2>
<p>There are a few project settings that can affect your performance.</p>
<h2 id="disable-unnecessary-player-or-quality-settings">Disable unnecessary Player or Quality settings</h2>
<p>In the Player settings, disable Auto Graphics API and remove graphics APIs that you don&#39;t plan on supporting for each of your targeted platforms. This can prevent generating excessive shader variants. Disable Target Architectures for older CPUs if your application is not supporting them.</p>
<p>In the Quality settings, disable needless Quality levels.</p>
<h2 id="switch-to-il2cpp">Switch to IL2CPP</h2>
<p>We recommend switching the Scripting Backend from Mono to IL2CPP (Intermediate Language to C++). Doing so will provide overall better runtime performance.</p>
<p>Be aware this does increase build times. Some developers prefer to use Mono locally for faster iteration, then switch to IL2CPP for build machines and/or release candidates. Refer to the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/IL2CPP.html">Optimizing IL2CPP build times</a> documentation to reduce your build times.</p>
<p>On PlayStation platforms where IL2CPP is the only option, locate the <strong>Player Settings &gt; Other Settings &gt; IL2CPP optimization level</strong> settings. Use the less optimal options during development to speed up build times. For profiling or final release, select <strong>Optimized Compile, Remove Unused Code, Optimized link</strong>.</p>
<p><span id="page-50-0"></span></p>
<table>
<thead>
<tr>
<th>BARRAN FOR PROPERTY PT</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Project Settings</td>
<td></td>
<td></td>
<td>0<br>x</td>
<td></td>
</tr>
<tr>
<td>Project Settings</td>
<td></td>
<td>9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Adaptive Performance<br>Audio</td>
<td>Player</td>
<td></td>
<td>021</td>
<td></td>
</tr>
<tr>
<td>Burst AOT Settings<br>Editor<br>Graphies<br>In-Editor Tutorials<br>Input Manager<br>W Input System Package<br>Settings<br>Memory Settings<br>Package Manager<br>y Physics<br>Settings<br>Physics 20<br>Player</td>
<td>Mac App Store Options<br>Override Default Bundle Identifier<br>Dundle Identifier<br>Build<br>Category<br>Mac App Store Validation<br>Configuration<br>Scripting Backend<br>Api Compatibility Level&quot;<br>Editor Assemblies Compatibility Level&quot;<br>IL2CPP Code Generation</td>
<td>V<br>com.unity.template.urp-sample<br>0<br>public.app=category.games<br>E<br>IL2CPP<br>NET Framework<br>Default ( NET Framework)<br>Faster runtime</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>Preset Manager<br>Quality<br>Scene Template<br>Script Execution Order<br>Services<br>ShaderGraph<br>Tags and Layers<br>TextMesh Pro<br>Time<br>Timeline<br>UI Toolkit<br>Version Control<br>VFX<br>XR Plugin Management</td>
<td>C++ Compiler Configuration<br>IL 2CPP Stacktrace Information<br>Use incremental GC<br>Allow downloads over HTTP .<br>Active Input Handling&quot;<br>Mac Configuration<br>Camera Usage Description&quot;<br>Microphone Usage Description®<br>Bluetooth Usage Description®<br>&gt; Supported URL schemes *<br>Shader Settings</td>
<td>Release<br>Method Name<br>&gt;<br>Not allowed<br>Input System Package (New)</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Shader Precision Model&quot;<br>Strict shader variant matching&quot;<br>Keep Loaded Shaders Alive&quot;<br>Shader Variant Loading Settings<br>Default chunk size (MB)*<br>Default chunk count&quot;<br>Override<br>Script Compilation<br>Scripting Define Symbols<br>Ust is Emply</td>
<td>Pletform Default<br>피<br>网<br>16<br>8<br>បា</td>
<td>+ ==</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Switch the scripting backend to IL2CPP</p>
<p>Using this option, Unity converts IL code from scripts and assemblies to C++ before creating a native binary file (e.g., .exe, .apk, .xap) for your target platform.</p>
<p>Please refer to the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/IL2CPP.html">documentation</a>, which provides information on how to optimize build times.</p>
<h2 id="avoid-large-hierarchies">Avoid large hierarchies</h2>
<p>Split your hierarchies. If your GameObjects do not need to be nested in a hierarchy, simplify the parenting. Smaller hierarchies benefit from multithreading to refresh the Transforms in your scene. Complex hierarchies incur unnecessary Transform computations and more cost to garbage collection.</p>
<p>See this <a href="https://youtu.be/W45-fsnPhJY?t=794">Unite talk</a> for best practices for Transforms.</p>
<h2 id="-span-id-page-51-0-span-graphics"><span id="page-51-0"></span>Graphics</h2>
<p>Because lighting and effects are quite complex, we recommend that you review the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/render-pipelines.html">render</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/render-pipelines.html">pipeline documentation</a> before attempting to optimize.</p>
<h3 id="commit-to-a-render-pipeline">Commit to a render pipeline</h3>
<p>Optimizing scene lighting is not an exact science but more an iterative process. It involves trial and error and the process usually depends on the artistic direction and render pipeline.</p>
<p>Before you begin lighting your scenes, you will need to choose one of the available render pipelines. A render pipeline performs a series of operations that take the contents of a scene to display them onscreen.</p>
<p>Unity provides three prebuilt render pipelines with different capabilities and performance characteristics, or, you can create your own.</p>
<ol>
<li>The <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/">Universal Render Pipeline (URP)</a> is a prebuilt <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ScriptableRenderPipeline.html?">Scriptable Render Pipeline</a> (SRP). URP provides artist-friendly workflows to create optimized graphics across a range of platforms, from mobile to high-end consoles and PCs. URP is the successor to the Built-In Render Pipeline, providing graphics and rendering features unavailable with the older pipeline. In order to maintain performance, it makes tradeoffs to reduce the computational cost of lighting and shading. Choose URP if you want to reach the most target platforms, including mobile and VR.</li>
</ol>
<p>Get a complete overview of the capabilities in URP in the e-book <em><a href="https://unity.com/resources/introduction-to-urp-advanced-creators-unity-6">Introduction to the</a>  <a href="https://unity.com/resources/introduction-to-urp-advanced-creators-unity-6">Universal Render Pipeline for advanced Unity creators</a></em>.</p>
<p><span id="page-52-0"></span><img src="_page_52_Picture_0.jpeg" alt=""></p>
<ol>
<li>The <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/index.html">High Definition Render Pipeline (HDRP)</a> is another prebuilt SRP designed for cutting-edge, high-fidelity graphics. HDRP targets high-end hardware such as PC, Xbox, and PlayStation. 2 It&#39;s the recommended render pipeline for creating photorealistic realistic graphics with the highest level of realism in your game, with advanced lighting, reflections, and shadows. HDRP uses physically based lighting and materials and supports improved debugging tools.</li>
</ol>
<p>Get a complete overview of the capabilities in HDRP in the e-book <em><a href="https://unity.com/resources/hdrp-lighting-environments-2022-lts-ebook">Lighting and</a>  <a href="https://unity.com/resources/hdrp-lighting-environments-2022-lts-ebook">environments in the High Definition Render Pipeline</a></em>.</p>
<ol>
<li>The <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/built-in-render-pipeline.html?">Built-in Render Pipeline</a> is Unity&#39;s older, general-purpose render pipeline with limited customization.</li>
</ol>
<h4 id="-around-90-of-unity-games-on-pc-console-are-using-srps-"><strong>Around 90% of Unity games on PC/console are using SRPs</strong></h4>
<p>The latest data available to Unity shows that URP is the most popular choice for games using Unity released on PC and console in 2023. The graph below shows that the Built-In Render Pipeline is now only used by a small fraction of development teams.</p>
<p><img src="_page_52_Figure_7.jpeg" alt=""></p>
<p>Proportion of games released using the different pipelines available from Unity</p>
<p><sup>2</sup> HDRP is not currently supported on mobile platforms. See the <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/System-Requirements.html">Requirements and compatibility page</a> for more details.</p>
<p>However, while most Unity projects are now being built on URP or HDRP, the Built-In Render Pipeline (see third option in the list) will remain an available option in Unity 6.</p>
<p><img src="_page_53_Figure_2.jpeg" alt=""></p>
<p>Choose a render pipeline early when planning your project.</p>
<p><span id="page-54-0"></span><img src="_page_54_Picture_1.jpeg" alt=""></p>
<p><em><a href="https://unity.com/demos/enemies">Enemies</a></em>, a demo created by Unity, showcases HDRP&#39;s high-end graphical capabilities.</p>
<p>URP and HDRP work on top of the Scriptable Render Pipeline (SRP). This is a thin API layer that lets you schedule and configure rendering commands using C# scripts. This flexibility allows you to customize virtually every part of the pipeline. You can also create your own <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/srp-custom.html?">custom</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/srp-custom.html?">render pipeline</a> based on SRP.</p>
<p>See <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/render-pipelines.html?">Render Pipelines in Unity</a> for a more detailed comparison of the available pipelines.</p>
<h4 id="-render-pipeline-packages-for-consoles-"><strong>Render pipeline packages for consoles</strong></h4>
<p>To build a Project for the <strong>PlayStation 4</strong>, <strong>PlayStation 5</strong>, <strong>Game Core Xbox</strong>, you need to install an additional package for each platform you want to support. The packages for each platform are:</p>
<ul>
<li><strong>PlayStation 4:</strong> com.unity.render-pipelines.ps4</li>
<li><strong>PlayStation 5</strong>: com.unity.render-pipelines.ps5</li>
<li><strong>Xbox consoles</strong>: com.unity.render-pipelines.gamecore</li>
</ul>
<p><span id="page-55-0"></span><img src="_page_55_Picture_1.jpeg" alt=""></p>
<p>Materials, such as skin or foliage, can benefit from the advanced lighting and shading features preconfigured with the HDRP.</p>
<h2 id="select-a-rendering-path">Select a rendering path</h2>
<p>While selecting a render pipeline, you should also consider a <strong>rendering path</strong>. The rendering path represents a specific series of operations related to lighting and shading. Deciding on a rendering path depends on your application needs and target hardware.</p>
<p><span id="page-56-0"></span><img src="_page_56_Picture_0.jpeg" alt=""></p>
<h4 id="-forward-"><strong>Forward</strong></h4>
<p>In forward rendering, the graphics card projects the geometry and splits it into vertices. Those vertices are further broken down into fragments, or pixels, which render to screen to create the final image.</p>
<p>The pipeline passes each object, one at a time, to the graphics API. Forward rendering comes with a cost for each light. The more lights in your scene, the longer rendering will take.</p>
<p><img src="_page_56_Figure_5.jpeg" alt=""></p>
<p>Forward Rendering path</p>
<p>The Built-in Pipeline&#39;s forward renderer draws each light in a separate pass per object. If you have multiple lights hitting the same GameObject, this can create significant overdraw, where overlapping areas need to draw the same pixel more than once. Minimize the number of realtime lights to reduce overdraw.</p>
<p>Rather than rendering one pass per light, the URP culls the lights per-object. This allows for the lighting to be computed in one single pass, resulting in fewer draw calls compared to the Built-In Render Pipeline&#39;s forward renderer.</p>
<h4 id="-forward-"><strong>Forward +</strong></h4>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/rendering/forward-plus-rendering-path.html">Forward+ rendering</a> improves upon standard Forward rendering by culling lights spatially rather than per object. This increases the overall number of lights that can be utilized in rendering a frame. In Deferred rendering it supports the Native RenderPass API, allowing G-buffer and lighting passes to be combined into a single render pass.</p>
<p><span id="page-57-0"></span><img src="_page_57_Picture_0.jpeg" alt=""></p>
<h4 id="-deferred-shading-"><strong>Deferred shading</strong></h4>
<p>In deferred shading, lighting is not calculated per object.</p>
<p><img src="_page_57_Figure_3.jpeg" alt=""></p>
<p>Deferred shading path</p>
<p><img src="_page_57_Picture_5.jpeg" alt=""></p>
<p>Deferred shading applies lighting to a buffer instead of each object.</p>
<p>Deferred shading instead postpones lighting calculation to a later stage. Deferred shading uses two passes.</p>
<p>In the first pass, or the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/RenderTech-DeferredShading.html?">G-Buffer</a> geometry pass, Unity renders the GameObjects. This pass retrieves several types of geometric properties and stores them in a set of textures. G-buffer textures can include:</p>
<ul>
<li>diffuse and specular colors</li>
<li>surface smoothness</li>
<li>occlusion</li>
<li>world space normals</li>
<li>emission + ambient + reflections + lightmaps</li>
</ul>
<p><span id="page-58-0"></span><img src="_page_58_Picture_0.jpeg" alt=""></p>
<p>In the second pass, or <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/RenderTech-DeferredShading.html?">lighting pass</a>, Unity renders the scene&#39;s lighting based on the G-buffer. Imagine iterating over each pixel and calculating the lighting information based on the buffer instead of the individual objects. Thus, adding more non-shadow casting lights in deferred shading does not incur the same performance hit as with forward rendering.</p>
<p>Though choosing a rendering path is not an optimization per se, it can affect <em>how</em> you optimize your project. The other techniques and workflows in this section may vary depending on what render pipeline and which rendering path you&#39;ve chosen.</p>
<h3 id="optimize-shader-graph">Optimize Shader Graph</h3>
<p>Both HDRP and URP support <a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/index.html">Shader Graph,</a> a visual interface for shader creation. This allows some users to create complex shading effects that may have been previously out of reach. Use the 150+ nodes in the visual graph system to create more shaders. You can also make your own custom nodes with the API.</p>
<p><img src="_page_58_Picture_6.jpeg" alt=""></p>
<p>Build shaders using a visual interface.</p>
<p>Begin each Shader Graph with a compatible master node, which determines the graph&#39;s output. Add nodes and operators with the visual interface, and construct the shader logic.</p>
<p>This Shader Graph then passes into the render pipeline&#39;s backend. The final result is a ShaderLab shader, functionally similar to one written in HLSL or Cg.</p>
<p>Optimizing a Shader Graph follows many of the same rules that apply to traditional HLSL/ Cg Shaders. The more processing your Shader Graph does, the more it will impact the performance of your application.</p>
<p>If you are CPU-bound, optimizing your shaders won&#39;t improve frame rate, but may still improve your battery life for mobile platforms.</p>
<p><img src="_page_59_Picture_0.jpeg" alt=""></p>
<p>If you are GPU-bound, follow these guidelines for improving performance with Shader Graphs:</p>
<p>— <strong>Decimate your nodes:</strong> Remove unused nodes. Don&#39;t change any defaults or connect nodes unless those changes are necessary. Shader Graph compiles out any unused features automatically.</p>
<p>When possible, bake values into textures. For example, instead of using a node to brighten a texture, apply the extra brightness into the texture asset itself.</p>
<p>— <strong>Use a smaller data format</strong>: Switch to a smaller data structure when possible. Consider using Vector2 instead of Vector3 if it does not impact your project. You can also reduce precision if the situation allows (e.g. half instead of float).</p>
<table>
<thead>
<tr>
<th>Output of<br>Precision<br>@ Vector 4(4)</th>
<th>Inherit</th>
<th>V</th>
</tr>
</thead>
<tbody>
<tr>
<td>0<br>Vecto Inputs</td>
<td></td>
<td></td>
</tr>
<tr>
<td>@<br>= Vector 4<br>Matri</td>
<td>Vector 4</td>
<td></td>
</tr>
<tr>
<td>0<br>Vector 1<br>Grad</td>
<td>Vector 1</td>
<td></td>
</tr>
<tr>
<td>Matrix</td>
<td>Matrix 3<br>9</td>
<td></td>
</tr>
<tr>
<td>Gradient</td>
<td>Gradient<br>A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>+</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><img src="_page_59_Figure_7.jpeg" alt=""></p>
<ul>
<li><strong>Reduce math operations:</strong> Shader operations run many times per second, so optimize any math operators when possible. Try to blend results instead of creating a logical branch. Use constants, and combine scalar values before applying vectors. Finally, convert any properties that do not need to appear in the Inspector as in-line Nodes. All of these incremental speedups can help your frame budget.</li>
<li><strong>Branch a preview:</strong> As your graph gets larger, it may become slower to compile. Simplify your workflow with a separate, smaller branch just containing the operations you want to preview at the moment, then iterate more quickly on this smaller branch until you achieve the desired results.</li>
</ul>
<p>If the branch is not connected to the master node, you can safely leave the preview branch in your graph. Unity removes nodes that do not affect the final output during compilation.</p>
<p><span id="page-60-0"></span><img src="_page_60_Picture_0.jpeg" alt=""></p>
<p>— <strong>Manually optimize:</strong> Even if you&#39;re an experienced graphics programmer, you can still use a Shader Graph to lay down some boilerplate code for a script-based shader. Select the Shader Graph asset, then select Copy Shader from the context menu.</p>
<p>Create a new HLSL/Cg Shader and then paste in the copied Shader Graph. This is a oneway operation, but it lets you squeeze additional performance with manual optimizations.</p>
<h4 id="remove-built-in-shader-settings">Remove built-in shader settings</h4>
<p>Remove every shader that you don&#39;t use from the <strong>Always Included</strong> list of shaders in the Graphics Settings (<strong>Edit &gt; ProjectSettings &gt; Graphics</strong>). Add shaders here that you&#39;ll need for the lifetime of the application.</p>
<p><img src="_page_60_Picture_6.jpeg" alt=""></p>
<p>Always Included shaders</p>
<h2 id="strip-shader-variants">Strip shader variants</h2>
<p>Shader variants can be useful for platform-specific features but increase build times and file size.</p>
<p>You can use the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SL-PragmaDirectives.html?">Shader compilation pragma directives</a> to compile the shader differently for target platforms. Then, use a shader keyword (or <a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Keywords.html">Shader Graph Keyword</a> node) to create <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SL-MultipleProgramVariants.html?">shader variants</a> with certain features enabled or disabled.</p>
<p><img src="_page_61_Picture_0.jpeg" alt=""></p>
<p>You can prevent shader variants from being included in your build if you know that they are not required.</p>
<p>Parse the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/log-files.html">Editor.log</a> for shader timing and size. Locate the lines that begin with &quot;Compiled shader&quot; and &quot;Compressed shader.&quot;</p>
<p>In an example log, your TEST shader may show you:</p>
<table>
<thead>
<tr>
<th>Compiled shader &#39;TEST Standard (Specular setup)&#39; in 31.23s</th>
</tr>
</thead>
<tbody>
<tr>
<td>d3d9 (total internal programs: 482, unique: 474)</td>
</tr>
<tr>
<td>d3d11 (total internal programs: 482, unique: 466)</td>
</tr>
<tr>
<td>metal (total internal programs: 482, unique: 480)</td>
</tr>
<tr>
<td>glcore (total internal programs: 482, unique: 454)</td>
</tr>
<tr>
<td>Compressed shader &#39;TEST Standard (Specular setup)&#39; on d3d9 from 1.04MB to 0.14MB</td>
</tr>
<tr>
<td>Compressed shader &#39;TEST Standard (Specular setup)&#39; on d3d11 from 1.39MB to 0.12MB</td>
</tr>
<tr>
<td>Compressed shader &#39;TEST Standard (Specular setup)&#39; on metal from 2.56MB to 0.20MB</td>
</tr>
<tr>
<td>Compressed shader &#39;TEST Standard (Specular setup)&#39; on glcore from 2.04MB to 0.15MB</td>
</tr>
</tbody>
</table>
<p>This tells you a few things about this shader:</p>
<ul>
<li>The shader expands into 482 variants due to #pragma multi_compile and shader_feature.</li>
<li>Unity compresses the shader included in the game data to roughly the sum of the compressed sizes: 0.14+0.12+0.20+0.15 = 0.61MB.</li>
<li>At runtime, Unity keeps the compressed data in memory (0.61MB), while the data for your currently used graphics API is uncompressed. For example, if your current API was Metal, that would account for 2.56MB.</li>
</ul>
<p>After a build, <a href="https://github.com/Unity-Technologies/ProjectAuditor">Project Auditor</a> can parse the Editor.log to display a list of all shaders, shader keywords, and shader variants compiled into a project. It can also analyze the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/log-files.html">Player.log</a> after the game is run. This shows you what variants the application actually compiled and used at runtime.</p>
<p>Employ this information to build a scriptable shader stripping system and reduce the number of variants. This can improve build times, build sizes, and runtime memory usage.</p>
<p>Read the <a href="https://blog.unity.com/technology/stripping-scriptable-shader-variants?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-multiplatform&amp;utm_content=optimize-game-performance-2020-lts-ebook">Stripping scriptable shader variants</a> blog post to see this process in detail.</p>
<h2 id="-span-id-page-62-0-span-particle-simulations-particle-system-or-vfx-graph"><span id="page-62-0"></span>Particle simulations: Particle System or VFX Graph</h2>
<p>Unity 6 includes two particle simulation solutions for smoke, liquids, flames, or other effects:</p>
<p>— The <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Built-inParticleSystem.html?">Built-In Particle System</a> can simulate thousands of particles on the CPU. You can use C# scripts to define a system and its individual particles. Particle Systems can interact with Unity&#39;s underlying physics system and any colliders in your scene. Particle Systems offer maximum compatibility and work with any of Unity&#39;s supported build platforms.</p>
<p><img src="_page_62_Picture_4.jpeg" alt=""></p>
<p>A simple effects simulation using the Built-In Particle System</p>
<p>— The <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/VFXGraph.html?">VFX Graph</a> is the newer system that provides enhanced capabilities for creating sophisticated visual effects in Unity, particularly for projects targeting high-end graphics and performance. It moves calculations on the GPU using compute shaders and can simulate millions of particles in large-scale visual effects. The workflow includes a highly customizable graph view. Particles can also interact with the color and depth buffer.</p>
<p>Though it does not have access to the underlying physics system, a VFX Graph can interact with complex assets, such as Point Caches, Vector Fields, and Signed Distance Fields. VFX Graph works with both HDRP and URP and on <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-ComputeShader.html?">platforms that support</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-ComputeShader.html?">compute shaders.</a></p>
<p><span id="page-63-0"></span><img src="_page_63_Picture_1.jpeg" alt=""></p>
<p>Millions of particles on-screen created with the Visual Effect Graph</p>
<p>When selecting one of the two systems, keep device compatibility in mind. Most PCs and consoles support compute shaders, but many mobile devices do not. If your target platform does support <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-ComputeShader.html?">compute shaders,</a> Unity allows you to use both types of particle simulation in your project.</p>
<p>Learn more about creating high-end visual effects with the e-book <em><a href="https://unity.com/resources/definitive-guide-to-creating-visual-effects?isGated=false">The definitive guide to</a>  <a href="https://unity.com/resources/definitive-guide-to-creating-visual-effects?isGated=false">creating advanced visual effects in Unity</a></em>.</p>
<h2 id="smooth-with-anti-aliasing">Smooth with anti-aliasing</h2>
<p>Anti-aliasing helps smooth the image, reduce jagged edges, and minimize specular aliasing.</p>
<p>If you are using Forward rendering with the Built-in Render Pipeline, <a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">Multisample Anti-aliasing</a>  <a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">(MSAA)</a> is available in the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-QualitySettings.html?">Quality settings</a>. MSAA produces high-quality anti-aliasing, but it can be expensive. The <strong>MSAA Sample Count</strong> from the drop-down menu (None, 2X, 4X, 8X) defines how many samples the renderer uses to evaluate the effect.</p>
<p>If you are using Forward rendering with the URP or HDRP, you can enable MSAA on the Render Pipeline Asset.</p>
<table>
<thead>
<tr>
<th>@ Inspector</th>
<th></th>
<th>e</th>
</tr>
</thead>
<tbody>
<tr>
<td>Depth Texture</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Opaque Texture</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Opaque Downsampling</td>
<td>None</td>
<td>D</td>
</tr>
<tr>
<td>Terrain Holes</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>Quality</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HDR</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Anti Aliasing (MSAA)</td>
<td>2x</td>
<td></td>
</tr>
<tr>
<td>Render Scale</td>
<td></td>
</tr>
</tbody>
</table>
<p>In URP, locate the MSAA settings on the Render Pipeline Asset.</p>
<p>Alternatively, you can add anti-aliasing as a post-processing effect. This appears on the Camera component under <strong>Anti-aliasing</strong>:</p>
<ul>
<li><strong>Fast approximate anti-aliasing (FXAA)</strong> smooths edges on a per-pixel level. This is the least resource-intensive anti-aliasing and slightly blurs the final image.</li>
<li><strong>Subpixel morphological anti-aliasing (SMAA)</strong> blends pixels based on the borders of an image. This has much sharper results than FXAA and is suited for flat, cartoon-like, or clean art styles.</li>
</ul>
<p>In HDRP, you can also use FXAA and SMAA with the <strong>Post Anti-aliasing</strong> setting on the Camera. URP and HDRP also offer an additional option:</p>
<p>— <strong>Temporal anti-aliasing (TAA)</strong> smooths edges using frames from the history buffer. This works more effectively than FXAA but requires <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/Motion-Vectors.html">motion vectors</a> in order to work. TAA can also improve ambient occlusion and volumetrics. It is generally higher quality than FXAA, but costs more resources and can produce occasional ghosting artifacts.</p>
<p><img src="_page_64_Figure_8.jpeg" alt=""></p>
<p>TAA as a post anti-aliasing effect on an HDRP camera.</p>
<p><span id="page-65-0"></span><img src="_page_65_Picture_0.jpeg" alt=""></p>
<h2 id="spatial-temporal-post-processing">Spatial-Temporal Post-Processing</h2>
<p>Spatial-Temporal Post-Processing (STP) is designed to enhance visual quality across a wide range of platforms like mobile, consoles, and PCs. STP is a spatio-temporal anti-aliasing upscaler that works with both HDRP and URP render pipelines, offering high-quality content scaling without the need for changes to existing content. This solution is particularly optimized for GPU performance, ensuring faster rendering times and making it easier to achieve high performance while maintaining visual quality.</p>
<p>To enable STP in the URP:</p>
<ul>
<li>Select the active URP Asset in the Project window.</li>
<li>In the Inspector navigate to Quality &gt; Upscaling Filter and select Spatial-Temporal Post-Processing.</li>
</ul>
<p><img src="_page_65_Picture_7.jpeg" alt=""></p>
<p>Enabling STP within the URP Asset</p>
<p><span id="page-66-0"></span><img src="_page_66_Picture_0.jpeg" alt=""></p>
<h2 id="common-lighting-optimizations">Common lighting optimizations</h2>
<p>While lighting is a vast subject, these general tips can help you to optimize your resources.</p>
<h4 id="-bake-lightmaps-"><strong>Bake lightmaps</strong></h4>
<p>The fastest option to create lighting is one that doesn&#39;t need to be computed per-frame. To do this, use <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Lightmappers.html">Lightmapping</a> to &quot;bake&quot; static lighting just once, instead of calculating it in real-time.</p>
<p>Add dramatic lighting to your static geometry using <strong>Global Illumination (GI)</strong>. Mark objects with <strong>Contribute G</strong>I so you can store high-quality lighting in the form of lightmaps.</p>
<p>The process of generating a lightmapped environment takes longer than just placing a light in the scene in Unity, but this:</p>
<ul>
<li>Runs faster, 2-3 times faster for two-per-pixel lights</li>
<li>Looks better GI can calculate realistic-looking direct and indirect lighting. The lightmapper smooths and denoises the resulting map.</li>
</ul>
<p>Baked shadows and lighting can then render without the same performance hit of realtime lighting and shadows.</p>
<p>Complex scenes may require long bake times. If your hardware supports the <strong>Progressive GPU Lightmapper</strong>, this option can dramatically speed up your lightmap generation, up to tenfold in some cases.</p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p>Enable Contribute GI.</p>
<p><span id="page-67-0"></span></p>
<table>
<thead>
<tr>
<th>: 0 x<br>· Preview</th>
<th>B √ Mesh Renderer</th>
<th></th>
<th>C<br>12</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lightmap for &#39;House01 (1)&#39; Z<br>0<br>&amp; Baked▼</td>
<td>Materials</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Element O</td>
<td>@Matr_BuildingsJettys</td>
<td>O</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>V Lighting</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Cast Shadows</td>
<td>Off</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Contribute Global Illumination</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Receive Global Illumination</td>
<td>Lightmaps</td>
<td></td>
</tr>
<tr>
<td></td>
<td>T Lightmapping</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Scale In Lightmap</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Stitch Seams</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Lightmap Parameters</td>
<td>Scene Default Parameters</td>
<td>View</td>
</tr>
<tr>
<td></td>
<td>▼ Baked Lightmap</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Lightmap Index: 0</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Tiling X: 0.04518224</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Tiling Y: 0.04518224<br>Offset X: 0.2928251</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Offset Y: 0.770942</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Lightmap Resolution: 5</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Lightmap Object Scale: 1</td>
</tr>
</tbody>
</table>
<p>Adjust the lightmapping settings (<strong>Windows &gt; Rendering &gt; Lighting Settings</strong>) and lightmap size to limit memory usage.</p>
<p>Follow the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Lightmapping.html?">manual</a> to get started with Lightmapping in Unity.</p>
<h4 id="-minimize-reflection-probes-"><strong>Minimize reflection probes</strong></h4>
<p>A <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-ReflectionProbe.html?">Reflection Probe</a> component can create realistic reflections, but this can be very costly in terms of batches. Use low-resolution cubemaps, culling masks, and texture compression to improve runtime performance. Use <strong>Type: Baked</strong> to avoid per-frame updates.</p>
<p>If using <strong>Type: Realtime</strong> is necessary in URP, avoid <strong>Every Frame</strong> if possible. Adjust the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rendering.ReflectionProbeRefreshMode.html">Refresh Mode</a> and <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rendering.ReflectionProbeTimeSlicingMode.html">Time Slicing</a> settings to reduce the update rate. You can also control the refresh with the Via Scripting option and <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/ReflectionProbe.RenderProbe.html">render the probe</a> from a custom script.</p>
<p>If using <strong>Type: Realtime</strong> is necessary in HDRP, use <strong>On Demand</strong> mode. You can also modify the Frame Settings in <strong>Project Settings &gt; HDRP Default Settings</strong>. Reduce the quality and features under Realtime Reflection for improved performance.</p>
<h4 id="-adaptive-probe-volumes-"><strong>Adaptive Probe Volumes</strong></h4>
<p>Unity 6 introduces Adaptive Probe Volumes (APVs) which provide a sophisticated solution for handling global illumination in Unity, allowing for dynamic and efficient lighting in complex scenes. APVs can optimize both performance and visual quality, particularly on mobile and lower-end devices, while offering advanced capabilities for high-end platforms.</p>
<p>APVs offer a range of features to enhance global illumination, particularly in dynamic and large scenes. URP now supports per-vertex sampling for improved performance on lowerend devices, while VFX particles benefit from indirect lighting baked into probe volumes.</p>
<p><img src="_page_68_Picture_1.jpeg" alt=""></p>
<p>Having multiple APVs is helpful for having more control over the probe density in the level.</p>
<p>APV data can be streamed from disk to CPU and GPU, optimizing lighting information for large environments. Developers can bake and blend multiple lighting scenarios, allowing real-time transitions like day/night cycles. The system also supports sky occlusion, integrates with the Ray Intersector API for more efficient probe calculations, and offers control over Light Probe sample density to reduce light leaking and speed up iterations. The new C# baking API also enables independent baking of APV from lightmaps or reflection probes.</p>
<p><img src="_page_68_Figure_4.jpeg" alt=""></p>
<p>To get started using APVs, check out the talk <a href="https://www.youtube.com/watch?v=iU7X5xICkc8">Efficient and impactful lighting with</a>  <a href="https://www.youtube.com/watch?v=iU7X5xICkc8">Adaptive Probe Volumes</a> from GDC 2023.</p>
<h4 id="-span-id-page-69-0-span-disable-shadows-"><span id="page-69-0"></span><strong>Disable shadows</strong></h4>
<p>Shadow casting can be disabled per MeshRenderer and light. Disable shadows whenever possible to reduce draw calls.</p>
<p>You can also create fake shadows using a blurred texture applied to a simple mesh or quad underneath your characters. Otherwise, you can create blob shadows with custom shaders.</p>
<table>
<thead>
<tr>
<th>▼ 因 √ Mesh Renderer</th>
<th></th>
<th>2 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>▼ Materials</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Element O</td>
<td>· Matr_BuildingsJettys</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Lighting</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cast Shadows</td>
<td>Off</td>
<td></td>
</tr>
<tr>
<td>Contribute Global Illumination</td>
<td>Off<br>V</td>
<td></td>
</tr>
<tr>
<td>Receive Global Illumination</td>
<td>On</td>
<td>D</td>
</tr>
<tr>
<td>T Lightmapping</td>
<td>Iwo Sided</td>
<td></td>
</tr>
<tr>
<td>Scale In Lightmap</td>
<td>Shadows Only</td>
</tr>
</tbody>
</table>
<p>Disable shadow casting to reduce draw calls.</p>
<p>In particular, avoid enabling shadows for point lights. Each point light with shadows requires six shadow map passes per light – compare that with a single shadow map pass for a spotlight. Consider replacing point lights with spotlights where dynamic shadows are absolutely necessary. If you can avoid dynamic shadows, use a cubemap as a <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Light-cookie.html">Light.</a> <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Light-cookie.html">cookie</a> with your point lights instead.</p>
<h4 id="-substitute-a-shader-effect-"><strong>Substitute a shader effect</strong></h4>
<p>In some cases, you can apply simple tricks rather than adding multiple extra lights. For example, instead of creating a light that shines straight into the camera to give a rim lighting effect, use a Shader which simulates rim lighting (see <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SL-SurfaceShaderExamples.html">Surface Shader examples</a>  for an implementation of this in HLSL).</p>
<h4 id="-span-id-page-70-0-span-use-light-layers-"><span id="page-70-0"></span><strong>Use Light Layers</strong></h4>
<p>For complex scenes with multiple lights, separate your objects using layers, then confine each light&#39;s influence to a specific culling mask.</p>
<p><img src="_page_70_Figure_3.jpeg" alt=""></p>
<p>Layers can limit your light&#39;s influence to a specific culling mask.</p>
<h2 id="gpu-lightmapper">GPU Lightmapper</h2>
<p>The GPU Lightmapper is production ready in Unity 6. It dramatically accelerates lighting data generation by leveraging the GPU, offering significantly faster bake times compared to traditional CPU lightmapping. It introduces a new light baking backend that simplifies the codebase and delivers more predictable results. Additionally, the minimum GPU requirement has been lowered to 2GB, and also includes a new API for moving light probe positions at runtime, which is particularly useful for procedurally generated content, alongside various quality-of-life improvements.</p>
<p><img src="_page_70_Figure_7.jpeg" alt=""></p>
<h2 id="-span-id-page-71-0-span-gpu-optimization"><span id="page-71-0"></span>GPU optimization</h2>
<p>To optimize your graphics rendering, you&#39;ll need to understand the limitations of your target hardware and how to profile the GPU. Profiling helps you check and verify that the optimizations you&#39;re making are effective.</p>
<p>Use these best practices for reducing the rendering workload on the GPU.</p>
<h2 id="benchmark-the-gpu">Benchmark the GPU</h2>
<p>When profiling, it&#39;s useful to start with a benchmark to tell you what profiling results you should expect from specific GPUs.</p>
<p>See <a href="https://gfxbench.com/result.jsp">GFXBench</a> for a great list of different industry-standard benchmarks for GPUs and graphics cards. The website provides a good overview of the current GPUs available and how they stack up against each other.</p>
<h2 id="-span-id-page-72-0-span-watch-the-rendering-statistics"><span id="page-72-0"></span>Watch the rendering statistics</h2>
<p>Click the <strong>Stats</strong> button in the top right of the Game view. This window shows you real-time rendering information about your application during Play mode. Use this data to help optimize performance:</p>
<ul>
<li><strong>fps:</strong> Frames per second</li>
<li><strong>CPU Main:</strong> Total time to process one frame (and update the Editor for all windows)</li>
<li><strong>CPU Render:</strong> Total time to render one frame of the Game view</li>
<li>B<strong>atches:</strong> Groups of draw calls to be drawn together</li>
<li><strong>Tris (triangles) and Verts (vertices):</strong> Mesh geometry</li>
<li><strong>SetPass calls:</strong> The number of times Unity must switch shader passes to render the GameObjects on-screen; each pass can introduce extra CPU overhead.</li>
</ul>
<p>Note: In-Editor fps does not necessarily translate to build performance. We recommend that you profile your build for the most accurate results. Frame time in milliseconds is a <a href="http://www.mvps.org/directx/articles/fps_versus_frame_time.htm">more accurate metric than frames per second</a> when benchmarking, as outlined in the &quot;FPS: A deceptive metric&quot; section.</p>
<p><img src="_page_72_Picture_10.jpeg" alt=""></p>
<h2 id="-span-id-page-73-0-span-use-draw-call-batching"><span id="page-73-0"></span>Use draw call batching</h2>
<p>To draw a GameObject, Unity issues a draw call to the graphics API (e.g. OpenGL, Vulkan, or Direct3D). Each draw call is resource intensive. State changes between draw calls, such as switching materials, can cause performance overhead on the CPU side.</p>
<p>PC and console hardware can push a lot of draw calls, but the overhead of each call is still high enough to warrant trying to reduce them. On mobile devices, draw call optimization is vital. You can achieve this with <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/DrawCallBatching.html?">draw call batching.</a></p>
<p>Draw call batching minimizes these state changes and reduces the CPU cost of rendering objects. Unity can combine multiple objects into fewer batches using several techniques:</p>
<p>— <strong>SRP Batching</strong>: If you are using HDRP or URP, enable the <a href="https://blogs.unity3d.com/2019/02/28/srp-batcher-speed-up-your-rendering/?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-multiplatform&amp;utm_content=optimize-game-performance-2020-lts-ebook">SRP Batcher</a> in your Pipeline Asset under <strong>Advanced</strong>. When using compatible shaders, the SRP Batcher reduces the GPU setup between draw calls and makes material data persistent in GPU Memory. This can speed up your CPU rendering times significantly. Use fewer <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SL-MultipleProgramVariants.html?">Shader Variants</a> with a minimal amount of Keywords to improve SRP batching. Consult <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SRPBatcher.html?">this SRP documentation</a> to see how your project can take advantage of this rendering workflow.</p>
<table>
<thead>
<tr>
<th>1 Inspector</th>
<th></th>
<th>al</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pipeline Asset_High (Universal Render Pipeline Asset)</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Open</td>
</tr>
<tr>
<td>Addressable</td>
<td></td>
<td></td>
</tr>
<tr>
<td>General<br>A</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A<br>Quality</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Lighting<br>A</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shadows<br>A</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Post-processing</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Advanced</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SRP Batcher</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Dynamic Batching</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mixed Lighting</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Debug Level</td>
<td>Disabled</td>
<td>D</td>
</tr>
<tr>
<td>Shader Variant Log Level</td>
<td>Disabled</td>
<td>D</td>
</tr>
</tbody>
</table>
<p>SRP Batcher helps you <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/DrawCallBatching.html?">batch draw calls.</a></p>
<ul>
<li><strong>GPU instancing</strong>: If you have a large number of identical objects (e.g., buildings, trees, grass, and so on with the same mesh and material), use <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/GPUInstancing.html?">GPU instancing.</a> This technique batches them using graphics hardware. To enable GPU Instancing, select your material in the Project window, and, in the Inspector, check E<strong>nable Instancing</strong>.</li>
<li><strong>Static batching</strong>: For non-moving geometry, Unity can reduce draw calls for any meshes sharing the same material. It is more efficient than dynamic batching, but it uses more memory.</li>
</ul>
<p>Mark all meshes that never move as <strong>Batching Static</strong> in the Inspector. Unity combines all static meshes into one large mesh at build time. The <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/StaticBatchingUtility.html">StaticBatchingUtility</a> also allows you to create these static batches yourself at runtime (for example, after generating a procedural level of non-moving parts).</p>
<p>— <strong>Dynamic Batching</strong>: For small meshes, Unity can group and transform vertices on the CPU, then draw them all in one go. Note: Do not use this unless you have enough low-poly meshes (no more than 300 vertices each and 900 total vertex attributes). Otherwise, enabling it will waste CPU time looking for small meshes to batch.</p>
<p>You can maximize batching with a few simple rules:</p>
<ul>
<li>Use as few textures in a scene as possible. Fewer textures require fewer unique materials, making them easier to batch. Additionally, use texture atlases wherever possible.</li>
<li>Always bake lightmaps at the largest atlas size possible. Fewer lightmaps require fewer material state changes, but keep an eye on the memory footprint.</li>
<li>Be careful not to instance materials unintentionally. Accessing <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Renderer-material.html?">Renderer.material</a> in scripts duplicates the material and returns a reference to the new copy. This breaks any existing batch that already includes the material. If you wish to access the batched object&#39;s material, use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Renderer-sharedMaterial.html?">Renderer.sharedMaterial</a> instead.</li>
<li>Keep an eye on the number of static and dynamic batch counts versus the total draw call count by using the Profiler or the rendering stats during optimizations.</li>
</ul>
<p>Please refer to the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/DrawCallBatching.html?">draw call batching</a> documentation for more information.</p>
<h2 id="-span-id-page-75-0-span-check-the-frame-debugger"><span id="page-75-0"></span>Check the Frame Debugger</h2>
<p>The Frame Debugger allows you to freeze playback on a single frame and step through how Unity constructs a scene to identify optimization opportunities. Look for GameObjects that render unnecessarily, and disable those to reduce draw calls per frame.</p>
<p><img src="_page_75_Picture_3.jpeg" alt=""></p>
<p>The Frame Debugger breaks down each rendered frame.</p>
<p>Note: The Frame Debugger does not show individual draw calls or state changes. Only native GPU profilers give you detailed draw call and timing information. However, the Frame Debugger can still be very helpful in debugging pipeline problems or batching issues.</p>
<p>One advantage of the Unity Frame Debugger is that you can relate a draw call to a specific GameObject in the scene. This makes it easier to investigate certain issues that may not be possible in external frame debuggers.</p>
<p> For more information, read the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/FrameDebugger.html">Frame Debugger</a> documentation, and see the section <a href="#page-18-0">&quot;Use</a>  <a href="#page-18-0">native profiling and debugging tools</a>&quot; for a list of platform-specific debugging tools.</p>
<p><span id="page-76-0"></span><img src="_page_76_Picture_0.jpeg" alt=""></p>
<h2 id="optimize-fill-rate-and-reduce-overdraw">Optimize fill rate and reduce overdraw</h2>
<p>Fill rate refers to the number of pixels the GPU can render to the screen each second.</p>
<p>If your game is limited by fill rate, this means that it&#39;s trying to draw more pixels per frame than the GPU can handle.</p>
<p>Drawing on top of the same pixel multiple times is called overdraw. Overdraw decreases fill rate and costs extra memory bandwidth. The most common causes of overdraw are:</p>
<ul>
<li>Overlapping opaque or transparent geometry</li>
<li>Complex shaders, often with multiple render passes</li>
<li>Unoptimized particles</li>
<li>Overlapping UI elements</li>
</ul>
<p>While you want to minimize its effect, there is no one-size-fits-all approach to solving overdraw problems. Begin by experimenting with the above factors to reduce their impact.</p>
<h4 id="draw-order-and-render-queues">Draw order and render queues</h4>
<p>To combat overdraw, you should understand how Unity sorts objects before rendering them.</p>
<p>The Built-in Render Pipeline sorts GameObjects according to their <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/StandardShaderMaterialParameterRenderingMode.html">Rendering Mode</a> and <a href="https://docs.unity.cn/2023.1/Documentation/ScriptReference/Material-renderQueue.html">renderQueue</a>. Each object&#39;s shader places it in a <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rendering.RenderQueue.html">render queue</a>, which often determines its draw order.</p>
<p>Each render queue may follow different rules for sorting before Unity actually draws the objects to screen. For example, Unity sorts the Opaque Geometry queue front-to-back, but the Transparent queue sorts back-to-front.</p>
<p>Objects rendering on top of one another create overdraw. If you are using the Built-in Render Pipeline, you can visualize overdraw in the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ViewModes.html">Scene view control bar.</a> Switch the draw mode to Overdraw.</p>
<p><img src="_page_77_Picture_0.jpeg" alt=""></p>
<p><img src="_page_77_Picture_2.jpeg" alt=""></p>
<p><img src="_page_77_Picture_3.jpeg" alt=""></p>
<p><img src="_page_78_Picture_1.jpeg" alt=""></p>
<p>The same scene in Overdraw view – overlapping geometry is often a source of overdraw</p>
<p>HDRP controls the render queue slightly differently. To calculate the order of the render queue, the HDRP:</p>
<ul>
<li>Groups meshes by shared materials</li>
<li>Calculates the rendering order of those groups based on Material Priority</li>
<li>Sorts each group using each Mesh Renderer&#39;s Priority property.</li>
</ul>
<p>The resulting queue is a list of GameObjects that are first sorted by their material&#39;s Priority, then by their individual Mesh Renderer&#39;s Priority. This page on <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/Renderer-And-Material-Priority.html">Renderer and</a>  <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/Renderer-And-Material-Priority.html">Material Priority</a> illustrates this in more detail.</p>
<p>To visualize transparency overdraw with HDRP, use the Render Pipeline Debug window (<strong>Window &gt; Render Pipeline &gt; Render Pipeline Debug</strong>) to select TransparencyOverdraw.</p>
<p><img src="_page_78_Picture_9.jpeg" alt=""></p>
<p><img src="_page_79_Picture_1.jpeg" alt=""></p>
<p>To view transparency overdraw select Rendering, then from the Fullscreen Debug Mode drop down select TransparencyOverdraw.</p>
<p>Visualizing transparency overdraw</p>
<p><img src="_page_79_Picture_4.jpeg" alt=""></p>
<p>The heatmap provides a visual representation of the transparency layers being rendered in the scene, from blue to white. Blue indicates low overdraw and white indicates a critical level of transparency layers, which will impact performance.</p>
<p>By using the transparency overdraw visualization, developers can make informed decisions on how to optimize their scenes for better performance.</p>
<p>The HDRP Render Pipeline Debug window can visualize overdraw from transparent materials.</p>
<p>When correcting overdraw, these diagnostic tools can offer a visual barometer of your optimizations.</p>
<p><span id="page-80-0"></span><img src="_page_80_Picture_0.jpeg" alt=""></p>
<h3 id="optimizing-graphics-for-consoles">Optimizing graphics for consoles</h3>
<p>Though developing for Xbox consoles and PlayStation® does resemble working with their PC counterparts, those platforms require some of their own unique techniques. Achieving smooth frame rates often means focusing on GPU optimization.</p>
<h4 id="-identify-your-performance-bottlenecks-"><strong>Identify your performance bottlenecks</strong></h4>
<p>Make PIX for Xbox and PlayStation profiler tools part of your toolbox when it comes to optimization on these platforms.</p>
<p>To begin, locate a frame with a high GPU load. Microsoft and Sony provide excellent tools for analyzing your project&#39;s performance on both the CPU and on the GPU. Use your respective native profiler to break down the frame cost into its specific parts. This will be your starting point to improve graphics performance.</p>
<p><img src="_page_80_Figure_7.jpeg" alt=""></p>
<p>The view was GPU-bound on a PlayStation®4 Pro at roughly 45 milliseconds per frame.</p>
<h4 id="-reduce-the-batch-count-"><strong>Reduce the batch count</strong></h4>
<p>As with other platforms, optimization on console will often mean reducing draw call batches. There are a few techniques that might help.</p>
<ul>
<li>Use <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/OcclusionCulling.html?">Occlusion culling</a> to remove objects hidden behind foreground objects and reduce overdraw. Be aware this requires additional CPU processing, so use the Profiler to ensure moving work from the GPU to CPU is beneficial.</li>
<li><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/GPUInstancing.html?">GPU instancing</a> can also reduce your batches if you have many objects that share the same mesh and material. Limiting the number of models in your scene can improve performance. If it&#39;s done artfully, you can build a complex scene without making it look repetitive.</li>
</ul>
<p><span id="page-81-0"></span><img src="_page_81_Picture_0.jpeg" alt=""></p>
<p>— The <a href="https://blog.unity.com/technology/srp-batcher-speed-up-your-rendering?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-multiplatform&amp;utm_content=optimize-game-performance-2020-lts-ebook">SRP Batcher</a> can reduce the GPU setup between DrawCalls by batching <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SRPBatcher.html">Bind</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SRPBatcher.html">and Draw GPU commands.</a> To benefit from this SRP batching, use as many materials as needed, but restrict them to a small number of compatible shaders (e.g., Lit and Unlit shaders in URP and HDRP).</p>
<h4 id="-activate-graphics-jobs-"><strong>Activate Graphics Jobs</strong></h4>
<p>Enable this option in <strong>Player Settings &gt; Other Settings</strong> to take advantage of the PlayStation&#39;s or Xbox console&#39;s multi-core processors. <strong>Graphics Jobs</strong> allows Unity to spread the rendering work across multiple CPU cores, removing pressure from the render thread. See <a href="https://learn.unity.com/tutorial/optimizing-graphics-in-unity?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=console-pc-performance-optimization-ebook">Multithreaded Rendering and Graphics Jobs tutorial</a> for details.</p>
<h4 id="-profile-the-post-processing-"><strong>Profile the post-processing</strong></h4>
<p>Be sure to use post-processing assets that are optimized for consoles. Tools from the Asset Store that were originally authored for PC may consume more resources than necessary on Xbox consoles or PlayStation. Profile using native profilers to be certain.</p>
<h4 id="-avoid-tessellation-shaders-"><strong>Avoid tessellation shaders</strong></h4>
<p>Tessellation subdivides shapes into smaller versions of that shape. This can enhance detail through increased geometry. Though there are examples where tessellation does make sense like for creating tree bark, in general, avoid tessellation on consoles. They can be expensive on the GPU.</p>
<h4 id="-replace-geometry-shaders-with-compute-shaders-"><strong>Replace geometry shaders with compute shaders</strong></h4>
<p>Like tessellation shaders, geometry and vertex shaders can run twice per frame on the GPU – once during the depth pre-pass, and again during the shadow pass.</p>
<p>If you want to generate or modify vertex data on the GPU, a <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-ComputeShader.html?">compute shader</a> is often a better choice than a geometry shader. Doing the work in a compute shader means that the vertex shader that actually renders the geometry can be comparatively fast and simple.</p>
<h4 id="-aim-for-good-wavefront-occupancy-"><strong>Aim for good wavefront occupancy</strong></h4>
<p>When you send a draw call to the GPU, that work splits into many wavefronts that Unity distributes throughout the available SIMDs within the GPU.</p>
<p>Each SIMD has a maximum number of wavefronts that can be running at one time. Wavefront occupancy refers to how many wavefronts are currently in use relative to the maximum. This measures how well you are using the GPU&#39;s potential. Console specific performance analysis tools show wavefront occupancy in great detail.</p>
<p><span id="page-82-0"></span><img src="_page_82_Picture_1.jpeg" alt=""></p>
<p>Good versus bad wavefront occupancy</p>
<p>In the above example, vertex shader wavefronts appear in green. Pixel shader wavefronts appear in blue. On the bottom graph, many vertex shader wavefronts appear without much pixel shader activity. This shows an underutilization of the GPU&#39;s potential.</p>
<p>If you&#39;re doing a lot of vertex shader work that doesn&#39;t result in pixels, that may indicate an inefficiency. While low wavefront occupancy is not necessarily bad, it&#39;s a metric to start optimizing your shaders and checking for other bottlenecks. For example, if you have a stall due to memory or compute operations, increasing occupancy may help performance. On the other hand, too many in-flight wavefronts can cause cache thrashing and decrease performance.</p>
<p><span id="page-83-0"></span><img src="_page_83_Picture_0.jpeg" alt=""></p>
<h4 id="-use-hdrp-built-in-and-custom-passes-"><strong>Use HDRP built-in and custom passes</strong></h4>
<p>If your project uses HDRP, take advantage of its built-in and custom passes. These can assist in rendering the scene. The built-in passes can help you optimize your shaders. HDRP includes several injection points where you can add custom passes to your shaders.</p>
<p><img src="_page_83_Figure_3.jpeg" alt=""></p>
<p>Use HDRP injection points to customize the pipeline.</p>
<p>For optimizing the behavior of transparent materials, refer to this page on <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/Renderer-And-Material-Priority.html">Renderer and</a>  <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/Renderer-And-Material-Priority.html">Material Priority.</a></p>
<h4 id="-reduce-the-size-of-shadow-mapping-render-targets-"><strong>Reduce the size of shadow mapping render targets</strong></h4>
<p>The High Quality setting of HDRP defaults to using a 4K shadow map. Reduce the shadow map resolution and measure the impact on the frame cost. Just be aware that you may need to compensate for any changes in visual quality with the light&#39;s settings.</p>
<h4 id="-utilize-async-compute-"><strong>Utilize Async Compute</strong></h4>
<p>If you have intervals where you are underutilizing the GPU, Async Compute allows you to move useful compute shader work in parallel to your graphics queue. This makes better use of those GPU resources.</p>
<p>For example, during shadow map generation, the GPU performs depth-only rendering. Very little pixel shader work happens at this point, and many wavefronts remain unoccupied.</p>
<p><img src="_page_84_Figure_1.jpeg" alt=""></p>
<p><img src="_page_85_Figure_1.jpeg" alt=""></p>
<p><span id="page-85-0"></span>If you can synchronize some compute shader work with the depth-only rendering, this makes for a better overall use of the GPU. The unused wavefronts could help with Screen Space Ambient Occlusion or any task that complements the current work.</p>
<p>In the above example, several optimizations shaved several milliseconds off the shadow mapping, lighting pass, and atmospherics. The resulting frame cost allowed the application to run at 30 fps on a PlayStation®4 Pro.</p>
<h4 id="culling">Culling</h4>
<p>Occlusion culling disables GameObjects that are fully hidden (occluded) by other GameObjects. This prevents the CPU and GPU from using time to render objects that will never be seen by the Camera.</p>
<p><a href="https://en.wikipedia.org/wiki/Hidden-surface_determination">Culling</a> happens per camera. It can have a large impact on performance, especially when multiple cameras are enabled concurrently. Unity uses two types of culling, frustum culling and occlusion culling.</p>
<p>Frustum culling is performed automatically on every Camera. It prevents GameObjects that are outside of the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/UnderstandingFrustum.html?">View Frustum</a> from being rendered, helping to optimize performance.</p>
<p>You can set <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Camera-layerCullDistances.html">per-layer culling distances</a> manually via <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Camera-layerCullDistances.html?">Camera.layerCullDistances</a>. This allows you to cull small GameObjects at a distance shorter than the default <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Camera-farClipPlane.html">farClipPlane.</a></p>
<p>Organize GameObjects into Layers. Use the layerCullDistances array to assign each of the 32 layers a value less than the farClipPlane (or use 0 to default to the farClipPlane).</p>
<p>Optimized render at 30 fps</p>
<p><img src="_page_86_Picture_0.jpeg" alt=""></p>
<p>Unity culls by layer first, keeping GameObjects only on layers the Camera uses. Afterwards, frustum culling removes any GameObjects outside the camera frustum. Frustum culling is performed as a series of jobs to take advantage of available worker threads.</p>
<p>Each layer culling test is very fast (essentially just a bit mask operation). However, this cost could still add up with a very large number of GameObjects. If this becomes a problem for your project, you may need to implement some system to divide your world into &quot;sectors&quot; and disable sectors that are outside the Camera frustum in order to relieve some of the pressure on Unity&#39;s layer/frustum culling system.</p>
<p><strong><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/OcclusionCulling.html">Occlusion culling</a></strong> removes any GameObjects from the Game view if the Camera cannot see them. Use this feature to prevent rendering of objects hidden behind other objects since these can still render and cost resources. For example, rendering another room is unnecessary if a door is closed and the Camera cannot see into the room.</p>
<p>Enabling occlusion culling can significantly increase performance but can also require more disk space, CPU time, and RAM. Unity bakes the occlusion data during the build and then needs to load it from disk to RAM while loading a scene.</p>
<p>While frustum culling outside the camera view is automatic, occlusion culling is a baked process. Simply mark your objects as Static.Occluders or Occludees, then bake through the <strong>Window &gt; Rendering &gt; Occlusion Culling</strong> dialog.</p>
<p><img src="_page_86_Picture_7.jpeg" alt=""></p>
<p>Check out the <a href="https://learn.unity.com/tutorial/working-with-occlusion-culling?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-multiplatform&amp;utm_content=optimize-game-performance-2020-lts-ebook">Working with Occlusion Culling</a> tutorial for more information.</p>
<p><span id="page-87-0"></span><img src="_page_87_Picture_1.jpeg" alt=""></p>
<p>An example of occlusion culling</p>
<h2 id="dynamic-resolution">Dynamic resolution</h2>
<p><strong>Allow Dynamic Resolution</strong> is a Camera setting that allows you to dynamically scale individual render targets to reduce workload on the GPU. In cases where the application&#39;s frame rate reduces, you can gradually scale down the resolution to maintain a consistent frame rate.</p>
<p>Unity triggers this scaling if performance data suggests that the frame rate is about to decrease as a result of being GPU-bound. You can also preemptively trigger this scaling manually with script. This is useful if you are approaching a GPU-intensive section of the application. If scaled gradually, dynamic resolution can be almost unnoticeable.</p>
<p>Refer to the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/DynamicResolution.html?">dynamic resolution</a> manual page for additional information and a list of supported platforms.</p>
<h3 id="multiple-camera-views">Multiple camera views</h3>
<p>Sometimes you may need to render from more than one point of view during your game. For example, it&#39;s common in an FPS game to draw the player&#39;s weapon and the environment separately with different fields of view (FOV). This prevents the foreground objects from feeling too distorted viewed through the wide-angle FOV of the background.</p>
<p><img src="_page_88_Picture_1.jpeg" alt=""></p>
<p>Camera Stacking in URP: the gun and background render with different camera settings</p>
<p>You could use <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/camera-stacking.html">Camera Stacking</a> in URP to render more than one camera view. However, there is still significant culling and rendering done for each camera. Each camera incurs some overhead, whether it&#39;s doing meaningful work or not. Only use Camera components required for rendering. On mobile platforms, each active camera can use up to 1 ms of CPU time, even when rendering nothing.</p>
<p><img src="_page_88_Picture_4.jpeg" alt=""></p>
<p>The Unity CPU Profiler shows the main thread in the timeline view and indicates that there are multiple Cameras. Unity performs culling for each Camera.</p>
<p><span id="page-89-0"></span><img src="_page_89_Picture_0.jpeg" alt=""></p>
<h4 id="-render-objects-renderer-feature-in-urp-"><strong>Render Objects Renderer Feature in URP</strong></h4>
<p>In the URP, instead of using multiple cameras, try a custom <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/renderer-features/renderer-feature-render-objects-landing.html">Render Objects Renderer Feature</a>. Select <strong>Add Renderer Feature</strong> in the <strong>Renderer Data</strong> asset. Choose <strong>Render Object</strong>.</p>
<table>
<thead>
<tr>
<th>Renderer Features</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt; &gt; Gun Opaques (Render Objects)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A<br>&lt; Gun Transparents (Render Objects)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>V Gun Transparents Overlay (Render Objects)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Name</td>
<td>GunTransparentsOverlay</td>
<td></td>
</tr>
<tr>
<td>Event</td>
<td>AfterRenderingTransparents</td>
<td>&gt;</td>
</tr>
<tr>
<td>Filters</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Queue</td>
<td>Transparent</td>
<td>&gt;</td>
</tr>
<tr>
<td>Layer Mask</td>
<td>First Person Objects P2</td>
<td></td>
</tr>
<tr>
<td>T LightMode Tags</td>
<td>O</td>
<td></td>
</tr>
<tr>
<td>List is Empty</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>T Overrides</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Material</td>
<td>None (Material)</td>
<td>0</td>
</tr>
<tr>
<td>Depth</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Write Depth</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td>Depth Test</td>
<td>Always</td>
<td>&gt;</td>
</tr>
<tr>
<td>Stencil</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Value</td>
<td>0<br>0</td>
<td></td>
</tr>
<tr>
<td>Compare Function</td>
<td>Equal</td>
<td>&gt;</td>
</tr>
<tr>
<td>Pass</td>
<td>Keep</td>
<td>&gt;</td>
</tr>
<tr>
<td>Fail</td>
<td>Keep</td>
<td>&gt;</td>
</tr>
<tr>
<td>Z Fail</td>
<td>Keep</td>
<td>&gt;</td>
</tr>
<tr>
<td>Camera</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Field Of View</td>
<td>40</td>
<td></td>
</tr>
<tr>
<td>Position Offset</td>
<td>Y O<br>Z 0<br>× 0</td>
<td></td>
</tr>
<tr>
<td>Restore</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Add Renderer Feature</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Create a custom Render Object to override render settings.</p>
<p>When overriding each Render Object, you can:</p>
<ul>
<li>Associate it with an Event and inject it into a specific timing of the render loop</li>
<li>Filter by Render Queue (Transparent or Opaque) and LayerMask</li>
<li>Affect the Depth and Stencil settings</li>
<li>Modify the Camera settings (Field of View and Position Offset)</li>
</ul>
<p><span id="page-90-0"></span><img src="_page_90_Picture_0.jpeg" alt=""></p>
<p><img src="_page_90_Picture_1.jpeg" alt=""></p>
<p>A Render Objects Renderer Feature in URP combines multiple Layers into one rendered view.</p>
<h4 id="-custom-pass-volumes-in-hdrp-"><strong>Custom Pass Volumes in HDRP</strong></h4>
<p>In HDRP, you can use custom passes to similar effect. Configuring a <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/Custom-Pass.html">Custom Pass</a> using a Custom Pass Volume is analogous to using an <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/index.html">HDRP Volume</a>.</p>
<p>A Custom Pass allows you to:</p>
<ul>
<li>Change the appearance of materials in your scene</li>
<li>Change the order that Unity renders GameObjects</li>
<li>Read Camera buffers into shaders</li>
</ul>
<table>
<thead>
<tr>
<th>T Custom Pass Volume (Script)</th>
<th></th>
<th>0<br>14</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mode</td>
<td>Global</td>
<td>D</td>
</tr>
<tr>
<td>Injection Point</td>
<td>Before Transparent</td>
<td></td>
</tr>
<tr>
<td>Priority</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>Custom Passes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Custom Pass (FullScreenCustomPass)</td>
<td></td>
<td>Enabled V</td>
</tr>
<tr>
<td>Name</td>
<td>Custom Pass</td>
<td></td>
</tr>
<tr>
<td>Target Color Buffer</td>
<td>Camera</td>
<td>D</td>
</tr>
<tr>
<td>Target Depth Buffer</td>
<td>Camera</td>
<td>A</td>
</tr>
<tr>
<td>Clear Flags</td>
<td>None</td>
<td>&gt;</td>
</tr>
<tr>
<td>Fetch Color Buffer</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FullScreen Material</td>
<td>None (Material)</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>A Custom Pass Volume in HDRP</p>
<p>Using <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/Custom-Pass-Volume-Workflow.html">Custom Pass Volumes in HDRP</a> can help you avoid using extra Cameras and the additional overhead associated with them. Custom passes have extra flexibility in how they can interact with shaders. You can also extend the <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/Custom-Pass-Scripting.html">Custom Pass class with C#</a>.</p>
<p><span id="page-91-0"></span><img src="_page_91_Picture_0.jpeg" alt=""></p>
<h2 id="use-level-of-detail-lod-">Use Level of Detail (LOD)</h2>
<p>As objects move into the distance, <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/LevelOfDetail.html">Level of Detail</a> (LOD) can adjust or switch them to use lower-resolution meshes with simpler materials and shaders to aid GPU performance.</p>
<p><img src="_page_91_Picture_4.jpeg" alt=""></p>
<p>Example of a mesh using a Level of Detail Group</p>
<p><img src="_page_91_Picture_6.jpeg" alt=""></p>
<p>Source meshes, modeled at varying resolutions</p>
<p>See the <a href="https://learn.unity.com/tutorial/working-with-lods-2019-3?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=console-pc-performance-optimization-ebook">Working with LODs</a> course on Unity Learn for more detail.</p>
<h2 id="-span-id-page-92-0-span-profile-post-processing-effects"><span id="page-92-0"></span>Profile post-processing effects</h2>
<p>Profile your <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/integration-with-post-processing.html">post-processing effects</a> to see their cost on the GPU. Some fullscreen effects, like Bloom and depth of field, can be expensive, but experiment until you find a happy balance between visual quality and performance.</p>
<p>Post-processing tends not to fluctuate much at runtime. Once you&#39;ve determined your Volume Overrides, allot your post effects a static portion of your total frame budget.</p>
<p><img src="_page_92_Figure_4.jpeg" alt=""></p>
<p>Keep post-processing effects simple if possible.</p>
<h2 id="gpu-resident-drawer">GPU Resident Drawer</h2>
<p>The GPU Resident Drawer (available for both <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/gpu-resident-drawer.html">URP</a> and <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/gpu-resident-drawer.html">HDRP</a>) is a GPU-driven rendering system designed to optimize CPU time, offering significant performance benefits. It supports cross-platform rendering and is designed to work out-of-the-box with existing projects.</p>
<p><img src="_page_93_Picture_1.jpeg" alt=""></p>
<p>The garden environment from the <a href="https://unity.com/demos/urp-3d-sample">URP 3D Sample</a> running with the GPU Resident Drawer</p>
<p>The system can be enabled within the HDRP or URP Render Pipeline Asset. Select <strong>Instanced Drawing</strong> to enable it. you can also select if you want to enable it in Play mode only or in Edit mode as well.</p>
<p>When you enable GPU Resident Drawer, games that are CPU bound due to a high number of draw calls can improve in performance as the amount of draw calls is reduced. The improvements you will see are dependent on the scale of your scenes and the amount of instancing you utilize. The more instanceable objects you render, the larger the benefits you will see.</p>
<table>
<thead>
<tr>
<th>&gt; 11 DI</th>
<th></th>
<th></th>
<th>3 Q Layout .</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>O Inspector &amp; Project Settings Occlusion</td>
<td></td>
<td>33</td>
</tr>
<tr>
<td>Play Focused ▼ 系 =&gt; @ Stats Gizmos ▼<br>ale @ 1x</td>
<td>PC_High (Universal Render Pipeline Asset)</td>
<td></td>
<td>0 :</td>
</tr>
<tr>
<td></td>
<td>0</td>
<td></td>
<td>Open</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>V Rendering</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Renderer List</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>0 PC_High_Renderer (Universal Renderer Data)</td>
<td></td>
<td>0<br>Default</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>+</td>
</tr>
<tr>
<td></td>
<td>Depth Texture</td>
<td>전에</td>
<td></td>
</tr>
<tr>
<td>0 20 10</td>
<td>Opaque Texture</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>CORRENDE<br>200 1<br>.</td>
<td>Opaque Downsampling</td>
<td>2x Billnear</td>
<td></td>
</tr>
<tr>
<td>1 8 0 0 2 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</td>
<td>Terrain Holes</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>GPU Resident Drawer</td>
<td>Instanced Drawing</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Small-Mesh Screen-Percentage</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>GPU Occlusion Culling</td>
<td>国</td>
<td></td>
</tr>
<tr>
<td></td>
<td>T Quality</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>HDR</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Anti Allasing (MSAA)</td>
<td>Disabled</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Render Scale</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Upscaling Filter</td>
<td>Automatic</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LOD Cross Fade</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LOD Cross Fade Dithering Type</td>
<td>Blue Noise</td>
<td></td>
</tr>
<tr>
<td></td>
<td>V Lighting</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Main Light</td>
<td>Per Pixel</td>
<td>V</td>
</tr>
<tr>
<td></td>
<td>Cast Shadows</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Shadow Resolution</td>
<td>2048</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Light Probe System</td>
<td>Light Probe Groups</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Additional Lights</td>
<td>Per Pixel</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Per Object Limit</td>
<td></td>
<td>ਦ</td>
</tr>
<tr>
<td></td>
<td>Cast Shadows</td>
<td>S</td>
</tr>
</tbody>
</table>
<p>Select &#39;Instanced Drawing&#39; from the GPU Resident Drawer drop down</p>
<p><span id="page-94-0"></span>Upon selecting the Instanced Drawing option you may get a message in the UI warning you that the &quot;BatchRenderGroup Variants setting must be &#39;Keep All&#39;&quot;. Adjusting this option in the graphics settings completes the setup for the GPU Resident Drawer.</p>
<p><img src="_page_94_Picture_2.jpeg" alt=""></p>
<p>Setting the BatchRenderGroup varient to <strong>Keep All</strong></p>
<p>To learn more check out our discussion thread <a href="https://discussions.unity.com/t/gpu-driven-rendering-in-unity/930675">here</a>.</p>
<h4 id="gpu-occlusion-culling">GPU occlusion culling</h4>
<p>GPU occlusion culling, available for both <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/gpu-culling.html">URP</a> and <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/gpu-culling.html">HDRP,</a> works in tandem with the GPU Resident Drawer. It significantly boosts the performance by reducing the amount of overdraw for each frame, meaning the renderer is not wasting resources drawing things that are not seen.</p>
<p>To activate GPU occlusion culling locate the render pipeline asset and toggle the GPU Occlusion check box.</p>
<p>To enable the GPU Occlusion Culling in Debug Mode in Unity 6, go to <strong>Window &gt; Rendering &gt; Occlusion Culling</strong>. Here, you can visualize how objects are being culled by toggling various visualization options.</p>
<p><span id="page-95-0"></span><img src="_page_95_Picture_1.jpeg" alt=""></p>
<p>The GPU Occlusion Culling option in the Render Pipeline Asset.</p>
<h2 id="split-graphics-jobs">Split Graphics Jobs</h2>
<p>Split Graphics Jobs can help you get a more efficient execution of rendering commands on multiple CPU cores, improving performance by enabling better parallelism between rendering tasks.</p>
<p>It offers a threading mode that&#39;s supported on multiple desktop and console platforms. The primary improvement comes from reducing unnecessary synchronization between the main thread (responsible for general game logic and orchestration) and native graphics job threads (responsible for rendering tasks).</p>
<p>The performance improvements from this new threading mode scale with the number of draw calls submitted in each frame. More draw calls benefit more from these optimizations, complex scenes with many objects and textures can see significant performance enhancements.</p>
<p>Splits Graphics Jobs is available when using DX12 for Windows and also supported by Vulkan Players.</p>
<p>To enable it go to <strong>Project Settings &gt; Player &gt; Other Settings &gt; Graphics Jobs Mode &gt; Split</strong>.</p>
<p>We recommend that you always use Splits Graphics Jobs instead of the legacy and native modes that were available previously.</p>
<h2 id="-span-id-page-96-0-span-user-interface"><span id="page-96-0"></span>User interface</h2>
<h2 id="user-interface">User interface</h2>
<p>Unity offers two UI systems: The older Unity UI and the new UI Toolkit. <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/UIElements.html">UI Toolkit</a> is intended to become the recommended UI system. It&#39;s tailored for maximum performance and reusability, with workflows and authoring tools inspired by standard web technologies, meaning UI designers and artists will find it familiar if they already have experience designing web pages.</p>
<p>However, as of Unity 6, UI Toolkit does not have some features that <a href="https://docs.unity3d.com/Packages/com.unity.ugui@3.0/manual/index.html">Unity UI</a> and <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/GUIScriptingGuide.html">Immediate</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/GUIScriptingGuide.html">Mode GUI (IMGUI)</a> support. Unity UI and IMGUI are more appropriate for certain use cases, and are required to support legacy projects. See the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/UI-system-compare.html?">Comparison of UI systems in Unity</a> for more information.</p>
<h2 id="ugui-performance-optimization-tips">UGUI performance optimization tips</h2>
<p>Unity UI (UGUI) can often be a source of performance issues. The Canvas component generates and updates meshes for the UI elements and issues draw calls to the GPU. Its functioning can be expensive, so keep the following factors in mind when working with it.</p>
<h4 id="-divide-your-canvases-"><strong>Divide your Canvases</strong></h4>
<p>If you have one large Canvas with thousands of elements, updating a single UI element forces the whole Canvas to update, which can potentially generate a CPU spike.</p>
<p><span id="page-97-0"></span><img src="_page_97_Picture_0.jpeg" alt=""></p>
<p>Take advantage of UGUI&#39;s ability to support multiple Canvases. Divide UI elements based on how frequently they need to be refreshed. Keep static UI elements on a separate Canvas, and dynamic elements that update at the same time on smaller sub-canvases.</p>
<p>Ensure that all UI elements within each Canvas have the same Z value, materials, and textures.</p>
<h4 id="-hide-invisible-ui-elements-"><strong>Hide invisible UI elements</strong></h4>
<p>You might have UI elements that only appear sporadically in the game (e.g., a health bar that appears when a character takes damage). If your invisible UI element is active, it might still be using draw calls. Explicitly disable any invisible UI components and re-enable them as needed.</p>
<p>If you only need to turn off the Canvas&#39;s visibility, disable the Canvas component rather than the whole GameObject. This can prevent your game from having to rebuild meshes and vertices when you reenable it.</p>
<h4 id="-limit-graphicraycasters-and-disable-raycast-target-"><strong>Limit GraphicRaycasters and disable Raycast Target</strong></h4>
<p>Input events like onscreen touches or clicks require the GraphicRaycaster component. This simply loops through each input point on screen and checks if it&#39;s within a UI&#39;s RectTransform. You need a Graphic Raycaster on every Canvas that requires input, including sub-canvases.</p>
<p>While this is not really a raycaster (despite the name), there is some expense for each intersection check. Minimize the number of Graphic Raycasters by not adding them to noninteractive UI Canvases.</p>
<table>
<thead>
<tr>
<th>D &amp; Graphic Raycaster</th>
<th></th>
<th>S</th>
<th>7</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Script<br>Ignore Reversed Graphics</td>
<td>Q Graphic Ray caster</td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Blocking Objects</td>
<td>None</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Blocking Mask</td>
<td>Everything</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Remove GraphicRaycasters from non-interactive UI Canvases.</p>
<p>In addition, disable Raycast Target on all UI text and images that don&#39;t need it. If the UI is complex with many elements, all of these small changes can reduce unnecessary computation.</p>
<table>
<thead>
<tr>
<th>V Image<br>V</th>
<th></th>
<th>2<br>14</th>
</tr>
</thead>
<tbody>
<tr>
<td>Source Image</td>
<td>@BoatAttack-logo-W</td>
<td>0</td>
</tr>
<tr>
<td>Color</td>
<td></td>
<td>A</td>
</tr>
<tr>
<td>Material</td>
<td>None (Material)</td>
<td>O</td>
</tr>
<tr>
<td>Raycast Target</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Raycast Padding</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Maskable</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Image Type</td>
<td>Simple</td>
<td></td>
</tr>
<tr>
<td>Use Sprite Mesh</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Preserve Aspect</td>
<td>V</td>
</tr>
</tbody>
</table>
<p>Disable Raycast Target if possible.</p>
<p><span id="page-98-0"></span><img src="_page_98_Picture_0.jpeg" alt=""></p>
<h4 id="-avoid-layout-groups-"><strong>Avoid Layout Groups</strong></h4>
<p>Layout Groups update inefficiently, so use them sparingly. Avoid them entirely if your content isn&#39;t dynamic, and use anchors for proportional layouts instead. Otherwise, create custom code to disable the <a href="https://docs.unity3d.com/Packages/com.unity.ugui@3.0/manual/UIAutoLayout.html">Layout Group</a> components after they set up the UI.</p>
<p>If you do need to use Layout Groups (Horizontal, Vertical, Grid) for your dynamic elements, avoid nesting them to improve performance.</p>
<table>
<thead>
<tr>
<th>▼ = √ Grid Layout Group</th>
<th></th>
<th>8 花</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Padding<br>A</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cell Size</td>
<td>X 100<br>Y 100</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spacing</td>
<td>X 01<br>Y O</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Start Corner</td>
<td>Upper Left</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Start Axis</td>
<td>Horizontal</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Child Alignment</td>
<td>Upper Left</td>
<td></td>
<td>D</td>
</tr>
<tr>
<td>Constraint</td>
<td>Flexible</td>
<td></td>
</tr>
</tbody>
</table>
<p>Layout Groups can lower performance, especially when nested.</p>
<h4 id="-avoid-large-list-and-grid-views-"><strong>Avoid large List and Grid views</strong></h4>
<p>Large List and Grid views are expensive. If you need to create a large List or Grid view (e.g., an inventory screen with hundreds of items), consider reusing a smaller pool of UI elements rather than creating a UI element for every item. Check out this sample <a href="https://github.com/boonyifei/ScrollList">GitHub project</a> to see this in action.</p>
<h4 id="-avoid-numerous-overlaid-elements-"><strong>Avoid numerous overlaid elements</strong></h4>
<p>Layering lots of UI elements (e.g., cards stacked in a card battle game) creates overdraw. Customize your code to merge layered elements at runtime into fewer elements and batches.</p>
<h4 id="-when-using-a-fullscreen-ui-hide-everything-else-"><strong>When using a fullscreen UI, hide everything else</strong></h4>
<p>If your pause or start screen covers everything else in the scene, disable the camera that is rendering the 3D scene. Likewise, disable any background Canvas elements hidden behind the top Canvas.</p>
<p>Consider lowering the Application.targetFrameRate during a fullscreen UI, since you should not need to update at 60 fps.</p>
<h4 id="-assign-the-camera-to-world-space-and-camera-space-canvases-"><strong>Assign the Camera to World Space and Camera Space Canvases</strong></h4>
<p>Leaving the <strong>Event</strong> or <strong>Render Camera</strong> field blank forces Unity to fill in <strong>Camera.main</strong>, which is unnecessarily expensive.</p>
<p><span id="page-99-0"></span><img src="_page_99_Picture_0.jpeg" alt=""></p>
<p>Consider using <strong>Screen Space – Overlay</strong> for your Canvas <strong>RenderMode</strong> if possible, as that does not require a camera.</p>
<table>
<thead>
<tr>
<th>C √ Canvas</th>
<th></th>
<th>2 :</th>
</tr>
</thead>
<tbody>
<tr>
<td>Render Mode</td>
<td>World Space</td>
<td></td>
</tr>
<tr>
<td>Event Camera</td>
<td>Main Camera (Camera)</td>
<td>O</td>
</tr>
<tr>
<td>Sorting Layer</td>
<td>Default</td>
<td></td>
</tr>
<tr>
<td>Order in Layer</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>Additional Shader Channels Mixed</td>
<td></td>
</tr>
</tbody>
</table>
<p>When using World Space Render Mode, make sure to fill in the Event Camera.</p>
<h2 id="ui-toolkit-performance-optimization-tips">UI Toolkit performance optimization tips</h2>
<p>If your game is UI heavy the general recommendation is to leverage UI Toolkit with Unity 6.</p>
<p>UI Toolkit offers improved performance over Unity UI, is tailored for maximum performance and reusability, and provides workflows and authoring tools inspired by standard web technologies. One of its key benefits is that it uses a highly optimized rendering pipeline that is specifically designed for UI elements.</p>
<p>Here are some general recommendations for optimizing performance of your UI with UI Toolkit:</p>
<h4 id="-use-efficient-layouts-"><strong>Use efficient layouts</strong></h4>
<p>Efficient layouts refer to using <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/UIE-LayoutEngine.html">layout groups</a> provided by UI Toolkit, such as Flexbox, instead of manually positioning and resizing UI elements. Layout groups handle the layout calculations automatically, which can significantly improve performance. They ensure that UI elements are arranged and sized correctly based on the specified layout rules. By utilizing efficient layouts, you avoid the overhead of manual layout calculations and achieve consistent and optimized UI rendering.</p>
<h4 id="-avoid-expensive-operations-in-update-"><strong>Avoid expensive operations in Update</strong></h4>
<p>Minimize the amount of work performed in Update methods, especially heavy operations like UI element creation, manipulation, or calculation. Perform these operations sparingly or during initialization when possible, since the update method is called once per frame.</p>
<h4 id="-optimize-event-handling-"><strong>Optimize event handling</strong></h4>
<p>Be mindful of event subscriptions and unregister them when no longer needed. Excessive event handling can impact performance, so ensure you only subscribe to events that are necessary.</p>
<p><span id="page-100-0"></span><img src="_page_100_Picture_0.jpeg" alt=""></p>
<h4 id="-optimize-style-sheets-"><strong>Optimize style sheets</strong></h4>
<p>Be mindful of the number of style classes and selectors used in your style sheets. Large style sheets with numerous rules can impact performance. Keep your style sheets lean and avoid unnecessary complexity.</p>
<h4 id="-profile-and-optimize-"><strong>Profile and optimize</strong></h4>
<p>Use Unity&#39;s profiling tools to identify performance bottlenecks in your UI and spot areas that can be optimized further, such as inefficient layout calculations or excessive redraws.</p>
<h4 id="-test-on-target-platforms-"><strong>Test on target platforms</strong></h4>
<p>Test your UI performance on target platforms to ensure optimal performance across different devices. Performance can vary based on hardware capabilities, so consider the target platform when optimizing your UI.</p>
<p>Remember, performance optimization is an iterative process. Continuously profile, measure, and optimize your UI code to ensure it runs smoothly and efficiently.</p>
<h2 id="-span-id-page-101-0-span-audio"><span id="page-101-0"></span>Audio</h2>
<p>Although audio is not normally a performance bottleneck, you can still optimize to save memory, disk space, or CPU usage.</p>
<h4 id="use-lossless-files-as-your-source">Use lossless files as your source</h4>
<p>Start with your sound assets in a lossless file format like WAV or AIFF.</p>
<p>If you use any compressed format (such as MP3 or Vorbis), then Unity will decompress it and recompress it during build time. This results in two lossy passes, degrading the final quality.</p>
<p><img src="_page_101_Picture_5.jpeg" alt=""></p>
<p>Audio loading CPU usage in the Unity Profiler</p>
<h2 id="-span-id-page-102-0-span-reduce-your-audioclip"><span id="page-102-0"></span>Reduce your AudioClip</h2>
<p><img src="_page_102_Picture_2.jpeg" alt=""></p>
<p>AudioClip Import Settings</p>
<p><img src="_page_103_Picture_0.jpeg" alt=""></p>
<p>Import settings on Audio Clips can save runtime memory and CPU performance:</p>
<p>— Enable the <strong>Force To Mono</strong> option on stereo audio files if they do not require stereo sound; this saves runtime memory and disk space.</p>
<p>Spatial Audio Sources should use AudioClips which are either authored in mono or have Force To Mono enabled in their import settings. If you use stereo sounds in spatial Audio Sources, the audio data will take up twice the disk space and memory; Unity must convert the sound to mono during the audio mixing process, which also requires extra CPU processing time.</p>
<ul>
<li><strong>Preload Audio Data</strong> ensures that Unity will load any referenced AudioClips before initializing the scene. However, this may increase scene loading times.</li>
<li>If your sound clip is not needed immediately, load it asynchronously. Check <strong>Load in Background</strong>. This loads the sound at a delayed time on a separate thread, without blocking the main thread.</li>
<li>Set the <strong>Sample Rate Setting</strong> to Optimize Sample Rate or Override Sample Rate.</li>
</ul>
<p>For mobile platforms, 22050 Hz should be sufficient. Use 44100Hz (i.e. CD-quality) sparingly. 48000Hz is excessive.</p>
<p>For PC/console platforms, 44100Hz is ideal. 48000Hz is usually unnecessary.</p>
<p>— Compress the AudioClip and reduce the compression bitrate.</p>
<p>For mobile platforms, use Vorbis for most sounds (or MP3 for sounds not intended to loop). Use ADPCM for short, frequently used sounds (e .g ., footsteps, gunshots).</p>
<p>For PC and Xbox®, use the Microsoft XMA codec instead of Vorbis or MP3. Microsoft recommends a compression ratio between 8:1 and 15:1.</p>
<p>For Playstation, use the ATRAC9 format. This has less CPU overhead than Vorbis or MP3.</p>
<p>— The proper Load Type depends on the length of the clip.</p>
<table>
<thead>
<tr>
<th>Clip size</th>
<th>Example usage<br>Load type settings</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Small<br>(&lt; 200 KB)</td>
<td>Noisy sound<br>effects (footsteps,<br>gunshots), UI sounds</td>
<td>Use Decompress on Load. This incurs a small<br>CPU cost to decompress a sound into raw 16-bit<br>PCM audio data, but will be the most performant<br>at runtime.<br>Or set to Compressed In Memory and set<br>Compression Format to ADPCM. This offers a<br>fixed 3.5:1 compression ratio and is inexpensive<br>to decompress in real-time.</td>
</tr>
</tbody>
</table>
<p><span id="page-104-0"></span><img src="_page_104_Picture_0.jpeg" alt=""></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>Optimal Load Type depends on the project&#39;s<br>priorities.</th>
</tr>
</thead>
<tbody>
<tr>
<td>Medium<br>(&gt;= 200 KB)</td>
<td>Dialog, short music,<br>medium/non-noisy<br>sounds effects</td>
<td>If reducing memory usage is the priority, select<br>Compressed In Memory.</td>
</tr>
<tr>
<td></td>
<td></td>
<td>If CPU usage is a concern, clips should be set to<br>Decompress On Load.</td>
</tr>
<tr>
<td>Large<br>(&gt; 350-400 KB)</td>
<td>Background music,<br>ambient background<br>noise, long dialog</td>
<td>Set to Streaming. Streaming has a 200 KB<br>overhead, so it is only suitable for sufficiently<br>large AudioClips.</td>
</tr>
</tbody>
</table>
<h2 id="optimize-the-audiomixer">Optimize the AudioMixer</h2>
<p>In addition to your AudioClip settings, be aware of these issues with the AudioMixer.</p>
<p>— The <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-AudioReverbEffect.html?">SFX Reverb Effect</a> is one of the most expensive audio effects in the AudioMixer. Adding a mixer group with SFX Reverb (and a mixer group sending to it) increases CPU cost.</p>
<p>This happens even if there is no AudioSource actually sending a signal to the groups. Unity&#39;s audio systetm doesn&#39;t distinguish if it&#39;s getting null signals or not.</p>
<p><img src="_page_104_Figure_6.jpeg" alt=""></p>
<p>Adding a Reverb group and a group sending to it is expensive, even if no AudioSource writes to it.</p>
<p>— Reduce the number of mixer groups to improve AudioMixer performance. Adding a large number of child groups under a single parent group increases audio CPU cost significantly. This happens even if all AudioSource outputs straight to Master, since Unity&#39;s DSP does not distinguish null signals.</p>
<p><img src="_page_105_Picture_2.jpeg" alt=""></p>
<p>An AudioMixer group with too many child groups</p>
<p>— Avoid parents with a single child group. Whenever possible, combine the two mixer groups into one.</p>
<p><img src="_page_105_Figure_5.jpeg" alt=""></p>
<p>An AudioMixer with single child groups</p>
<h2 id="-span-id-page-106-0-span-physics"><span id="page-106-0"></span>Physics</h2>
<p>Physics can create intricate gameplay, but this comes with a performance cost. When you know these costs, you can tweak the simulation to manage them appropriately. These tips can help you stay within your target frame rate and create smooth playback with Unity&#39;s <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/PhysicsOverview.html">built-in 3D</a> <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/PhysicsOverview.html">physics,</a> which is an integration of the NVIDIA PhysX engine.</p>
<p><span id="page-107-0"></span><img src="_page_107_Picture_0.jpeg" alt=""></p>
<h2 id="simplify-colliders">Simplify colliders</h2>
<p>Mesh colliders can be expensive. Substitute more complex mesh colliders with primitive or simplified mesh colliders to approximate the original shape.</p>
<p><img src="_page_107_Picture_3.jpeg" alt=""></p>
<p>Use primitives or simplified meshes for colliders.</p>
<p><span id="page-108-0"></span><img src="_page_108_Picture_0.jpeg" alt=""></p>
<h2 id="optimize-your-settings">Optimize your settings</h2>
<p>In the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-PlayerSettings.html">PlayerSettings,</a> check <strong>Prebake Collision Meshes</strong> whenever possible.</p>
<table>
<thead>
<tr>
<th>Optimization</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Prebake Collision Meshes*</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Keep Loaded Shaders Alive *</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Preloaded Assets*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AOT Compilation Options*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Strip Engine Code*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Managed Stripping Level</td>
<td>Low</td>
<td>D</td>
</tr>
<tr>
<td>Script Call Optimization*</td>
<td>Slow and Safe</td>
<td>D</td>
</tr>
<tr>
<td>Vertex Compression*</td>
<td>Mixed</td>
<td>P</td>
</tr>
<tr>
<td>Optimize Mesh Data*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Texture MipMap Stripping*</td>
<td></td>
</tr>
</tbody>
</table>
<p>Enable Prebake Collision Meshes</p>
<p>Make sure that you edit your Physics settings (<strong>Project Settings &gt; Physics</strong>) as well. Simplify your Layer Collision Matrix wherever possible.</p>
<table>
<thead>
<tr>
<th>* Project Settings</th>
<th></th>
<th></th>
<th>Q</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adaptive Performance</td>
<td>Physics Settings</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Audio<br>Burst AOT Settings</td>
<td>Shared<br>Game Object</td>
<td>Cloth</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Editor<br>Graphics<br>In-Editor Tutorials<br>Input Manager<br>v Input System Package<br>Settings<br>Memory Settings<br>Package Manager<br>V Physics<br>Settings<br>Physics 2D<br>Player<br>Preset Manager<br>T Quality<br>HORP<br>Scene Template<br>Script Execution Order<br>Services<br>ShaderGraph<br>Tags and Layers<br>TextMesh Pro<br>Time<br>Timeline<br>Ul Toolkit<br>Version Control<br>VFX<br>Visual Scripting<br>XR Plugin Management</td>
<td>Default Material<br>Bounce Threshold<br>Default Max Depenetration Velocity<br>Sleep Threshold<br>Default Contact Offset<br>Default Solver Iterations<br>Default Solver Velocity Iterations<br>Queries Hit Backfaces<br>Queries Hit Triggers<br>Enable Adaptive Force<br>Simulation Mode<br>Auto Sync Transforms<br>Reuse Collision Callbacks<br>Invoke Collision Callbacks<br>Contact Pairs Mode<br>Broadphase Type<br>Friction Type<br>Enable Enhanced Determinism<br>Enable Unified Heightmaps<br>Improved Patch Friction<br>Solver Type<br>Default Max Angular Speed<br>Scratch Buffer Chunk Count<br>Fast Motion Threshold</td>
<td>None (Physics Material)<br>2<br>10<br>0.005<br>0.01<br>6<br>1<br>&gt;<br>Fixed Update<br>&gt;<br>&gt;<br>Default Contact Pairs<br>Sweep And Prune Broadphase<br>Patch Friction Type<br>&gt;<br>Projected Gauss Seidel<br>7<br>47<br>3.402823e438</td>
<td></td>
<td>0<br>V<br>A<br>V</td>
</tr>
</tbody>
</table>
<p>Modify the physics project settings to squeeze out more performance.</p>
<h2 id="-span-id-page-109-0-span-adjust-simulation-frequency"><span id="page-109-0"></span>Adjust simulation frequency</h2>
<p>Physics engines work by running on a fixed time step. To see the fixed rate that your project is running at, go to <strong>Edit &gt; Project Settings &gt; Time</strong>.</p>
<p>The <strong>Fixed Timestep</strong> field defines the time delta used by each physics step. For example, the default value of 0.02 seconds (20 ms) is equivalent to 50 fps, or 50 Hz.</p>
<p><img src="_page_109_Picture_4.jpeg" alt=""></p>
<p>The default Fixed Timestep in the Project Settings is 0.02 seconds (50 frames per second).</p>
<p>Because each frame in Unity takes a variable amount of time, it is not perfectly synced with the physics simulation. The engine counts up to the next physics time step. If a frame runs slightly slower or faster, Unity uses the elapsed time to know when to run the physics simulation at the proper time step.</p>
<p>In the event that a frame takes a long time to prepare, this can lead to performance issues. For example, if your game experiences a spike (e.g., instantiating many GameObjects or loading a file from disk), the frame could take 40 ms or more to run. With the default 20 ms Fixed Timestep, this would cause two physics simulations to run on the following frame in order to &quot;catch up&quot; with the variable time step.</p>
<p>Extra physics simulations, in turn, add more time to process the frame. On lower-end platforms, this potentially leads to a downward spiral of performance.</p>
<p><img src="_page_110_Picture_0.jpeg" alt=""></p>
<p>A subsequent frame taking longer to prepare makes the backlog of physics simulations longer as well. This leads to even slower frames and even more simulations to run per frame. The result is worse and worse performance.</p>
<p>Eventually the time between physics updates could exceed the Maximum Allowed Timestep. After this cutoff, Unity starts dropping physics updates, and the game stutters.</p>
<p>To avoid performance issues with physics:</p>
<ul>
<li>Reduce the simulation frequency. For lower-end platforms, increase the <strong>Fixed Timestep</strong>  to slightly more than your target frame rate. For example, use 0.035 seconds for 30ps on mobile. This could help prevent that downward performance spiral.</li>
<li>Decrease the <strong>Maximum Allowed Timestep</strong>. Using a smaller value (like 0.1 s) sacrifices some physics simulation accuracy, but also limits how many physics updates can happen in one frame. Experiment with values to find something that works for your project&#39;s requirements.</li>
<li>Simulate the physics step manually if necessary by choosing the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/SimulationMode.html">SimulationMode</a> during the Update phase of the frame. This allows you to take control when to run the physics step. Pass Time.deltaTime to Physics.Simulate in order to keep the physics in sync with the simulation time.</li>
</ul>
<p>This approach can cause instabilities in the physics simulation in scenes with complex physics or highly variable frame times, so use it with caution.</p>
<table>
<thead>
<tr>
<th>Profiler Modules</th>
<th></th>
<th>· Playmode · 1 1 1 1 1 Frame: 79/143 Clear on Play Deep Profile Call Stacks ·</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>g</th>
<th>113<br>0</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU Usage</td>
<td></td>
<td>66ms (15FPS)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Selected: TransformChangedDispatch</td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Rendering<br>· Scripts<br>= Physics<br>· Animation</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GarbageCollector<br>VSync<br>Global Illumination</td>
<td></td>
<td>33ms (30FPS)<br>16ms (60FPS)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>UI<br>Others</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0.00ms</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Rendering<br>Batches Count</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>227<br>94,551</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Timeline</td>
<td>· Live</td>
<td></td>
<td></td>
<td>CPU:39.99ms GPU :-- ms</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Main Thread</td>
<td></td>
<td></td>
<td>11.0ms 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</td>
<td>PlayerLoop (32.88ms)</td>
<td></td>
<td></td>
<td>1 12 12.0ms</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Update. Script Run Behaviour Update (31.73ms)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>OnM</td>
<td></td>
<td></td>
<td>BehaviourUpdate (31,72ms)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Sider Trans</td>
<td>Physics Processing (0.92ms)</td>
<td>DelayUpdateLoop.Update() {31.65ms}</td>
<td></td>
<td>7sics.FetchResults (0.24n</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Render Thread</td>
<td></td>
<td>Physics. Processing<br>0.000ms<br>Total: 0.079ms (9 Instances)</td>
<td></td>
<td>G(x.WaitForGfxCommandsFromMainThread (32.17ms)<br>Semaphore.WaitForSignal (32.17ms)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Profiling a scene in Unity with manual simulation</p>
<h2 id="-span-id-page-111-0-span-modify-cookingoptions-for-meshcolliders"><span id="page-111-0"></span>Modify CookingOptions for MeshColliders</h2>
<p>Meshes used in physics go through a process called cooking. This prepares the mesh so that it can work with physics queries like raycasts, contacts, and so on.</p>
<p>A MeshCollider has several <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MeshColliderCookingOptions.html?">CookingOptions</a> to help you validate the mesh for physics. If you are certain that your mesh does not need these checks, you can disable them to speed up your cook time.</p>
<p>In the CookingOptions for each MeshCollider, simply uncheck the EnableMeshCleaning, WeldColocatedVertices, and CookForFasterSimulation. These options are valuable for procedurally generated meshes at runtime, but can be disabled if your meshes already have the proper triangles.</p>
<p>Also, if you are targeting PC, make sure you keep Use Fast Midphase enabled. This switches to a faster algorithm from PhysX 4.1 during the mid-phase of the simulation (which helps narrow down a small set of potentially intersecting triangles for physics queries).</p>
<p><img src="_page_111_Picture_7.jpeg" alt=""></p>
<p>Cooking options for a mesh</p>
<h2 id="-span-id-page-112-0-span-use-physics-bakemesh"><span id="page-112-0"></span>Use Physics.BakeMesh</h2>
<p>If you are generating meshes procedurally during gameplay, you can create a Mesh Collider at runtime. Adding a MeshCollider component directly to the mesh, however, cooks/bakes the physics on the main thread. This can consume significant CPU time.</p>
<p>Use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.BakeMesh.html">Physics.BakeMesh</a> to prepare a mesh for use with a MeshCollider and save the baked data with the mesh itself. A new MeshCollider referencing this mesh will reuse this prebaked data (rather than baking the mesh again). This can help reduce Scene load time or instantiation time later.</p>
<p>To optimize performance, you can offload mesh cooking to another thread with the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/JobSystemOverview.html">C# job</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/JobSystemOverview.html">system</a>. Refer to <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.BakeMesh.html">this example</a> for details on how to bake meshes across multiple threads.</p>
<p><img src="_page_112_Figure_5.jpeg" alt=""></p>
<p>BakeMeshJob in the Profiler</p>
<h2 id="use-box-pruning-for-large-scenes">Use Box Pruning for large scenes</h2>
<p>The Unity physics engine runs in two steps:</p>
<ul>
<li>The <strong>broad phase</strong>, which collects potential collisions using a <a href="https://en.wikipedia.org/wiki/Sweep_and_prune">sweep and prune</a> algorithm</li>
<li>The <strong>narrow phase</strong>, where the engine actually computes the collisions</li>
</ul>
<p>The broad phase default setting of Sweep and Prune BroadPhase (<strong>Edit &gt; Project Settings &gt;</strong> </p>
<p><img src="_page_113_Picture_0.jpeg" alt=""></p>
<p><strong>Physics &gt; BroadPhase Type</strong>) can generate false positives for worlds that are generally flat and have many colliders.</p>
<p>If your scene is large and mostly flat, avoid this issue and switch to <strong>Automatic Box Pruning</strong> or <strong>Multibox Pruning Broadphase</strong>. These options divide the world into a grid, where each grid cell performs sweep-and-prune.</p>
<p>Multibox Pruning Broadphase allows you to specify the world boundaries and the number of grid cells manually, while Automatic Box Pruning calculates that for you.</p>
<table>
<thead>
<tr>
<th>Project Settings<br>Project Settings</th>
<th></th>
<th>14</th>
<th>0 X</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Adaptive Performance<br>Audio<br>Burst AOT Settings<br>Editor<br>Graphics<br>In-Editor Tutorials<br>Input Manager<br>v Input System Package<br>Settings<br>Memory Settings<br>Package Manager<br>v Physics<br>Settings<br>Physics 2D<br>Player<br>Preset Manager<br>Y Quality<br>HORP<br>Scene Template<br>Script Execution Order<br>Services<br>ShaderGraph<br>Tags and Layers<br>TextMesh Pro<br>Time<br>Timolino<br>Ul Toolkit<br>Version Control<br>VEX<br>Visual Scripting<br>XR Plugin Management</td>
<td>Physics Settings<br>Shared Game Object<br>Cloth<br>Default Material<br>Bounce Threshold<br>2<br>Default Max Depenetration Velocity 10<br>0.005<br>Sleep Threshold<br>0.01<br>Default Contact Offset<br>Default Schrer Rerations<br>6<br>Default Solver Velocity Iterations<br>1)<br>Queries Hit Backfaces<br>Queries Hit Triggers<br>&gt;<br>Enable Adaptive Force<br>Simulation Mode<br>Fixed Update<br>Auto Sync Transforms<br>Rouse Collision Callbacks<br>S<br>Invoke Collision Callbacks<br>S<br>Contact Pairs Mode<br>Broadphase Type<br>Friction Type<br>Enable Enhanced Determinism<br>Enable Unified Heightmaps<br>Improved Patch Friction<br>Soher Type<br>Default Max Anguiar Speed<br>7<br>Scratch Buffer Chunk Count<br>4<br>3.402823e=38<br>Fast Motion Threshold</td>
<td>None (Physics Material)<br>Default Contact Pairs<br>Sweep And Prune Broadphase<br>V Sweep And Prune Broadphase<br>Automatic Box Pruning<br>Projected Gauss Seidel</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Broadphase Type in the Physics options</p>
<h2 id="-span-id-page-114-0-span-modify-solver-iterations"><span id="page-114-0"></span>Modify solver iterations</h2>
<p>If you want to simulate a specific physics body more accurately, increase its <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody-solverIterations.html?">Rigidbody.</a> <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody-solverIterations.html?">solverIterations</a>.</p>
<p><img src="_page_114_Picture_3.jpeg" alt=""></p>
<p>Override the Default Solver Iterations per Rigidbody</p>
<p>This overrides the Physics.defaultSolverIterations, which can also be found in <strong>Edit &gt; Project Settings &gt; Physics &gt; Default Solver Iterations</strong>.</p>
<p>To optimize your physics simulations, set a relatively low value in the project&#39;s defaultSolveIterations. Then apply higher custom Rigidbody.solverIterations values to the individual instances that need more detail.</p>
<h2 id="-span-id-page-115-0-span-disable-automatic-transform-syncing"><span id="page-115-0"></span>Disable automatic transform syncing</h2>
<p>By default, Unity does not automatically synchronize changes to Transforms with the physics engine. Instead, it waits until the next physics update or until you manually call <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.SyncTransforms.html">Physics.</a> <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.SyncTransforms.html">SyncTransforms</a>. When this is enabled, any <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody.html?">Rigidbody</a> or <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Collider.html?">Collider</a> on that <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Transform.html?">Transform</a> or its children automatically sync with the physics engine.</p>
<h4 id="-when-to-manually-sync-"><strong>When to manually sync</strong></h4>
<p>When autoSyncTransforms is disabled, Unity only synchronizes transformations before the physics simulation step in FixedUpdate or when explicitly requested through Physics.Simulate. You might need to perform additional syncs if you use APIs that read directly from the physics engine between Transform changes and the physics update. Examples include accessing <strong>Rigidbody.position</strong> or performing <strong>Physics.Raycast</strong>.</p>
<h4 id="-performance-best-practice-"><strong>Performance best practice</strong></h4>
<p>Although autoSyncTransforms ensures up-to-date physics queries, it incurs a performance cost. Each physics-related API call forces a sync, which can degrade performance, especially with multiple successive queries. Follow these best practices:</p>
<ul>
<li><strong>Disable autoSyncTransforms unless necessary</strong>: Only enable it if precise, continuous syncing is crucial for your game mechanics.</li>
<li><strong>Use manual syncing</strong>: For better performance, manually synchronize Transforms with Physics.SyncTransforms() before calls that require the latest Transform data. This approach is more efficient than enabling autoSyncTransforms globally.</li>
</ul>
<table>
<thead>
<tr>
<th>@ Project Settings</th>
<th></th>
<th></th>
<th>0<br>×<br>1</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>* Project Settings</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Adaptive Performance</td>
<td>Physics Settings</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Audio<br>Burst AOT Settings</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Editor</td>
<td>Game Object<br>Shared</td>
<td>Cloth</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Graphics</td>
<td>Default Material</td>
<td>None (Physics Material)</td>
<td>@</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>In-Editor Tutorials</td>
<td>Bounce Threshold</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Input Meneger<br>r Input System Package</td>
<td>Default Max Depenetration Velocity</td>
<td>10</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Settings</td>
<td>Sleep Theeshold</td>
<td>0.005</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Memory Settings</td>
<td>Default Contact Officet</td>
<td>0.01</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Package Manager</td>
<td>Default Solver iterations</td>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v Physics<br>Settings</td>
<td>Default Solver Velocity Iterations</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Physics 2D</td>
<td>Queries Hit Backfaces</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Player</td>
<td>Queries Hit Triggers</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Preset Manager<br>Quality</td>
<td>Enable Adaptive Force</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Scene Template</td>
<td>Simulation Mode</td>
<td>Fixed Update</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Script Execution Order</td>
<td>Auto Sync Transforms</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Services</td>
<td>Reuse Collision Calibacks</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ShederGraph<br>Tags and Lavers</td>
<td>Invoka Collision Callbacks</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TextMesh Pro-</td>
<td>Contact Pairs Mode</td>
<td>Default Contact Pairs</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Time</td>
<td>Broadphase Type</td>
<td>Sweep And Prune Broadphase</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Timeline<br>UI Toolick</td>
<td>Friction Type</td>
<td>Patch Friction Type</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Version Control</td>
<td>Enable Enhanced Determinism</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>VEX</td>
<td>Enable Unified Heightmaps<br>Improved Patch Friction</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>XR Plugin Management</td>
<td>Salver Type</td>
<td>Projected Gauss Seldel</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Default Max Angular Speed</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Scratch Buffer Churk Count</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Fast Motion Threshold</td>
<td>3.402023e+30</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Profiling a scene in Unity with Auto Sync Transform disabled</p>
<h2 id="-span-id-page-116-0-span-use-contact-arrays"><span id="page-116-0"></span>Use Contact Arrays</h2>
<p><a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.ContactEvent.html">Contact Arrays</a> gives you a method where collision data (contacts) is stored and managed in an array format. This means that every collision event generates an array of contact points, which can be accessed and processed. Being an array it provides a contiguous block of memory, which speeds up access times when processing collision data and sets it up for batch processing and can be combined with the C# Job System in performance-critical use cases.</p>
<h2 id="reuse-collision-callbacks">Reuse Collision Callbacks</h2>
<p>Contact arrays are generally significantly faster and so the general recommendation is to use those rather than reusing collision callbacks, however consider the following if you do have a specific use case for it.</p>
<p>The callbacks <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MonoBehaviour.OnCollisionEnter.html">MonoBehaviour.OnCollisionEnter</a>, <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MonoBehaviour.OnCollisionStay.html?">MonoBehaviour.OnCollisionStay</a> and <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MonoBehaviour.OnCollisionExit.html?">MonoBehaviour.OnCollisionExit</a> all take a collision instance as a parameter. This collision instance is allocated on the managed heap and must be garbage collected.</p>
<p>To reduce the amount of garbage generated, enable <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics-reuseCollisionCallbacks.html?">Physics.reuseCollisionCallbacks</a> (also found in <strong>Projects Settings &gt; Physics &gt; Reuse Collision Callbacks</strong>). With this active, Unity only assigns a single collision pair instance to each callback. This reduces waste for the garbage collector and improves performance.</p>
<p>The general recommendation is to always enable Reuse Collision Callbacks for performance benefits. You should only disable this feature for legacy projects where the code relies on individual Collision class instances, making it impractical to store individual fields.</p>
<p><img src="_page_116_Picture_8.jpeg" alt=""></p>
<p>In the Unity Console, there is a single collision instance on Collision Entered and Collision Stay.</p>
<p><span id="page-117-0"></span><img src="_page_117_Picture_0.jpeg" alt=""></p>
<h2 id="move-static-colliders">Move static colliders</h2>
<p>Static colliders are GameObjects with a Collider component but without a Rigidbody.</p>
<p>Note that you can move a static collider, contrary to the term &quot;static.&quot; To do so, simply modify the position of the physics body. Accumulate the positional changes and sync before the physics update. You don&#39;t need to add a Rigidbody component to the static collider just to move it.</p>
<p>However, if you want the static collider to interact with other physics bodies in a more complex way, give it a <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody-isKinematic.html?">kinematic Rigidbody</a>. Use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody-position.html?">Rigidbody.position</a> and <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody-rotation.html?">Rigidbody.rotation</a> to move it instead of accessing the Transform component. This guarantees more predictable behavior from the physics engine.</p>
<p>Note: If an individual Static Collider 2D needs to be moved or reconfigured at runtime, then add a Rigidbody 2D component and set it to the Static Body Type, as it is faster to simulate the Collider 2D when it has its own Rigidbody 2D. If a group of Collider 2Ds needs to be moved or reconfigured at runtime, it is faster to have them all be children of the single hidden parent Rigidbody 2D than to move each GameObject individually.</p>
<h2 id="use-non-allocating-queries">Use non-allocating queries</h2>
<p>To detect and collect colliders in 3D projects within a certain distance and in a certain direction, use raycasts and other physics queries like <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.BoxCast.html">BoxCast</a>.</p>
<p>Note that Physics queries that return multiple colliders as an array, like <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.OverlapSphere.html">OverlapSphere</a> or <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.OverlapBox.html">OverlapBox</a>, need to allocate those objects on the managed heap. This means that the garbage collector eventually needs to collect the allocated objects, which can decrease performance if it happens at the wrong time.</p>
<p>To reduce this overhead, use the <strong>NonAlloc</strong> versions of those queries. For example, if you are using OverlapSphere to collect all potential colliders around a point, use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.OverlapSphereNonAlloc.html">OverlapSphereNonAlloc</a> instead.</p>
<p>This allows you to pass in an array of colliders (the results parameter) to act as a buffer. The NonAlloc method works without generating garbage. Otherwise, it functions like the corresponding allocating method.</p>
<p>Note that you need to define a results buffer of sufficient size when using a NonAlloc method. The buffer does not grow if it runs out of space.</p>
<h4 id="-2d-physics-"><strong>2D Physics</strong></h4>
<p>Note that the above advice does not apply to 2D physics queries, because in Unity&#39;s 2D physics system, methods do not have a &quot;NonAlloc&quot; suffix. Instead, all 2D physics methods, including those that return multiple results, provide overloads that accept arrays or lists. For instance, while the 3D physics system has methods like RaycastNonAlloc, the 2D equivalent</p>
<p><span id="page-118-0"></span><img src="_page_118_Picture_0.jpeg" alt=""></p>
<p>simply uses an overloaded version of Raycast that can take an array or List<T> as a parameter, such as:</p>
<pre><code><span class="hljs-keyword">var</span> results = <span class="hljs-keyword">new</span> <span class="hljs-built_in">List</span>&lt;RaycastHit2D&gt;();
<span class="hljs-built_in">int</span> hitCount = Physics2D.Raycast(origin, direction, contactFilter, results);
</code></pre><p>By using overloads, you can perform non-allocating queries in the 2D physics system without needing specialized NonAlloc methods.</p>
<h3 id="batch-queries-for-ray-casting">Batch queries for ray casting</h3>
<p>You can run raycast queries with <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.Raycast.html?">Physics.Raycast</a>. However, if you have a large number of raycast operations (e.g., calculating line of sight for 10,000 agents), this may take a significant amount of CPU time.</p>
<p>Use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/RaycastCommand.html?">RaycastCommand</a> to batch the query using the C# Job System. This offloads the work from the main thread so that the raycasts can happen asynchronously and in parallel.</p>
<p>See a usage example at the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/RaycastCommand.html?">RaycastCommands</a> documentation page.</p>
<h3 id="visualize-with-the-physics-debugger">Visualize with the Physics Debugger</h3>
<p>Use the Physics Debug window (<strong>Window &gt; Analysis &gt; Physics Debugger</strong>) to help troubleshoot any problem colliders or discrepancies. This shows a color-coded indicator of the GameObjects that can collide with one another.</p>
<p><img src="_page_118_Picture_11.jpeg" alt=""></p>
<p>The Physics Debugger helps you visualize how your physics objects can interact with one another.</p>
<p>For more information, see <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/PhysicsDebugVisualization.html">Physics Debugger documentation</a>.</p>
<h2 id="-span-id-page-119-0-span-animation"><span id="page-119-0"></span>Animation</h2>
<p>The following tips will help you when working with animation in Unity. For a comprehensive guide through the animation system, download the free e-book <em><a href="https://unity.com/resources/definitive-guide-animation-unity-2022-lts-ebook">The definitive guide to</a>  <a href="https://unity.com/resources/definitive-guide-animation-unity-2022-lts-ebook">animation in Unity</a></em>.</p>
<table>
<thead>
<tr>
<th>Armature Import Settings</th>
<th></th>
<th>Model Rig Animation Materials</th>
<th></th>
<th></th>
<th>24<br>Open</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Generic<br>Animation Type</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Create From This Model<br>Avatar Definition</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>None</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Standard (4 Bones)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Optimize Game Objects</td>
<td>I</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Revert Apply</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="use-generic-rather-than-humanoid-rigs">Use generic rather than humanoid rigs</h4>
<p>By default, Unity imports animated models with the generic rig, but developers often switch to the humanoid rig when animating a character. Be aware of these issues with rigs:</p>
<ul>
<li>Use a generic rig whenever possible. Humanoid rigs calculate inverse kinematics and animation retargeting each frame, even when not in use. Thus, they consume 30–50% more CPU time than their equivalent generic rigs.</li>
<li>When importing humanoid animation, use an Avatar Mask to remove IK goals or finger animation if you don&#39;t need them.</li>
<li>Maintain a bone weight count that&#39;s as low as possible.</li>
</ul>
<p>Generic rigs use less CPU time than humanoid rigs.</p>
<h2 id="-span-id-page-120-0-span-use-alternatives-for-simple-animation"><span id="page-120-0"></span>Use alternatives for simple animation</h2>
<p>Animators are primarily intended for humanoid characters. However, they are often repurposed to animate single values (e.g., the alpha channel of a UI element). Avoid overusing Animators, particularly in conjunction with UI elements, since they come with extra overhead.</p>
<p>The current animation system is optimized for animation blending and more complex setups. It has temporary buffers used for blending, and there is additional copying of the sampled curve and other data.</p>
<p>For static animations, especially the ones that have a lot of duplicates, such as crowds, you can try implementing baked animations. There are two common techniques: Vertex texture animations (including normal and tangent buffers) and a technique that uses baked bone matrices for manual skinning in a vertex shader.</p>
<p>Learn more about baking animations in <a href="https://learn.unity.com/tutorial/baking-animation-for-fbx-export">this Unity Learn tutorial</a> and in <a href="https://www.youtube.com/watch?v=Hh5zcT2IkaQ">this tutorial</a> by Llam Academy.</p>
<p>Also, if possible, consider not using the animation system at all. Create <a href="https://easings.net">easing functions</a> or use a third-party tweening library where possible (e.g., <a href="https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676?">DOTween)</a>. These can achieve very natural-looking interpolation with mathematical expressions.</p>
<h4 id="avoid-scale-curves">Avoid scale curves</h4>
<p>Animating scale curves is more expensive than animating translation and rotation curves. To improve performance, avoid scale animations.</p>
<p>Note: This does not apply to constant curves (curves that have the same value for the length of the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-AnimationClip.html?">animation clip</a>). Constant curves are optimized, and these are less expensive than normal curves.</p>
<h2 id="update-only-when-visible">Update only when visible</h2>
<p>Set the animators&#39;s <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-Animator.html?">Culling Mode</a> to Based on Renderers, and disable the S<a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-SkinnedMeshRenderer.html?">kinned Mesh</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-SkinnedMeshRenderer.html?">Renderer&#39;s</a> Update When Offscreen property. This saves Unity from updating animations when the character is not visible.</p>
<p><span id="page-121-0"></span><img src="_page_121_Picture_0.jpeg" alt=""></p>
<h2 id="optimize-workflow">Optimize workflow</h2>
<p>Other optimizations are possible at the scene level:</p>
<ul>
<li>Use hashes instead of strings to query the Animator.</li>
<li>Implement a small AI Layer to control the Animator. You can make it provide simple callbacks for OnStateChange, OnTransitionBegin, and other events.</li>
<li>Use State Tags to easily match your AI state machine to the Unity state machine.</li>
<li>Use additional curves to simulate events.</li>
<li>Use additional curves to mark up your animations, for example in conjunction with <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/TargetMatching.html?">target</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/TargetMatching.html?">matching</a>.</li>
</ul>
<h4 id="-separate-animating-hierarchies-"><strong>Separate animating hierarchies</strong></h4>
<p>Ensure that animating hierarchies do not share a common parent (unless that parent is the root of the scene). This separation prevents threading issues when writing the result of animation back to GameObjects, which can cause significant performance penalties.</p>
<h4 id="-minimize-binding-costs-"><strong>Minimize binding costs</strong></h4>
<p>Be aware of the high costs associated with binding operations in the animation system. To optimize performance, avoid frequently adding clips, adding or removing GameObjects and components, and enabling or disabling objects during runtime which generally require rebinding. All of these operations are computationally expensive.</p>
<h4 id="-avoid-using-component-based-constraints-on-deep-hierarchies-"><strong>Avoid using component-based constraints on deep hierarchies</strong></h4>
<p>Avoid using component-based constraints on deep hierarchies, such as characters with complex structures as this can result in poor performance.</p>
<h4 id="-consider-performance-implications-of-animation-rigging-"><strong>Consider performance implications of animation rigging</strong></h4>
<p>When using animation rigging, be mindful of the performance overhead introduced by each constraint. This consideration is important when working with humanoid models. Whenever possible, utilize the built-in IK (Inverse Kinematics) pass in the Humanoid rig to improve performance.</p>
<h2 id="-span-id-page-122-0-span-workflow-and-collaboration"><span id="page-122-0"></span>Workflow and collaboration</h2>
<p>Building an application in Unity is a huge endeavor that often involves many developers. Make sure that your project is set up optimally for your team.</p>
<h4 id="use-version-control">Use version control</h4>
<p>A version control system (VCS) allows you to keep a historical record of your entire project. It brings organization to your work and enables teams to iterate efficiently.</p>
<p>Project files are stored in a shared database called a repository, or &quot;repo.&quot; You backup your project at regular intervals to the repo, and if something goes wrong, you can revert back to an earlier version of the project.</p>
<p>With a VCS, you can make multiple individual changes and commit them as a single group for versioning. This commit sits as a point on the timeline of your project, so that if you need to revert back to a previous version, everything from that commit is undone and restored to the state it was at the time. You can review and modify each change grouped within a commit or undo the commit entirely.</p>
<p>With access to the project&#39;s entire history, it&#39;s easier to identify which changes introduced bugs, restore previously removed features, and easily document changes between your game or product releases.</p>
<p>What&#39;s more, because version control is typically stored in the cloud or on a distributed server, it supports your development team&#39;s collaboration from wherever they&#39;re working – an increasingly important benefit as remote work becomes commonplace.</p>
<p><span id="page-123-0"></span><img src="_page_123_Picture_0.jpeg" alt=""></p>
<p>verify that the Mode is set to <a href="https://discussions.unity.com/questions/932348/visible-or-hidden-meta-files-with-git.html?">Visible Meta Files</a>.</p>
<p>To help with version control merges, make sure your Editor settings have <strong>Asset Serialization Mode</strong> set to <strong>Force Text</strong>. This is less space efficient but makes Unity store scene files in a textbased format.</p>
<p><img src="_page_123_Picture_3.jpeg" alt=""></p>
<p>If you&#39;re using an external version control system (such as Git) in the Version Control settings,</p>
<p><img src="_page_123_Picture_5.jpeg" alt=""></p>
<p>Version Control Mode</p>
<p>Asset Serialization Mode</p>
<p>Unity also has a built-in YAML (a human-readable, data-serialization language) tool specifically for merging scenes and Prefabs. For more information, see <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SmartMerge.html">Smart merge</a> in the Unity documentation.</p>
<h2 id="unity-version-control">Unity Version Control</h2>
<p>Most Unity projects include a sizable amount of art assets in addition to the script code. If you want to manage these assets with version control, consider switching to <a href="https://unity.com/solutions/version-control">Unity Version Control</a> (UVCS, formerly known as Plastic SCM). Even with Git LFS, Git does not perform as well as Plastic SCM with larger repositories which offers superior speed when working with large binary files (&gt;500 MB).</p>
<table>
<thead>
<tr>
<th>Plastic SCM Cloud Organizations (Beta) &gt; Reportories &gt; Code reviews &gt; Crosenting &gt; Crossens &gt; &lt; Portonance ingrovements<br>&lt; chore(): Performance improvements<br>Updated 15 days ago<br>O Under review<br>If /main .* 17 /main/improve_performance<br>Conversation (2)<br>Changed Files (38)<br>Changesets (2)</th>
<th></th>
<th>8<br>Mark review as<br>0<br>0<br>Under review<br>O<br>GI<br>Rework required</th>
<th>2 Merge -<br>Mark review</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>国<br>Entire branch v<br>A<br>V</td>
<td></td>
<td>Reviewed<br>O<br>16<br>I unresolved issue from me</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Write<br>Previow</td>
<td>HBI &amp; 99 4<br>三 三 第</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1 -- 1011001 6100100200000</td>
<td>1 AYAML 1.1<br>2 STAC 101<br>1 -- 1021</td>
<td>Issue can be resolved in a followup! igtm otherwise</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>a 00)ectHideFlags: 1</td>
<td>5<br>a 00 jer</td>
<td></td>
<td>Mark as Review<br>Cancel</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>I Expand unchanged lines<br>Modifications: []<br>RemovedComponents! []<br>m_ParentPrefab: (fileID: @)<br>n PrefabParentObject: {fileID: 0}<br>m_PrefabInternal: (fileID: 108102000)<br>serializedversion: 5<br>n Companent :<br>- companent: {fileID: 4000013561567688}<br>- component: {fileID: 95@00018897851044}</td>
<td>7<br>8<br>9<br>10<br>12<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>29<br>22<br>22</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>A I  Bundles/Characters/Raccoon/character.prefab [] cs:1 . cs:2 Changed<br>1 NYML 1.1<br>2 STAG In! tag: unity3d.com, 2811:<br>4 Prefab:<br>5<br>serializedVersion: 2<br>ಳ<br>9<br>10<br>11<br>12 m RootGameObject: {fileID: 1000010415562562}<br>1J n_IsPrefabParent: 1<br>14 -- 1011 61000018415562562<br>15 GameObject:<br>16 m_ObjectHideFlags: @<br>17 -<br>18<br>19<br>28<br>21<br>27<br>23<br>= Coubocur: { { } (410-10; } } (410-13000200)<br>24<br>- component: {fileID: 82000012972505386}</td>
<td>4 Gamelbjed<br>n Press<br>ల<br>24</td>
<td>a Prefinancements a provention and consumers<br>serializedVersion: 5<br>= Component :<br>- conponent: {fileID: 465740}<br>- component: {fileID: 95@1716}<br>- component: {fileID: 11427384}<br>- (omponent: {fileID: #2000013563701790}<br>= component: {fileID: 114852966775052252}<br>n Layer: @<br>m Name: character<br>. Tagstring: Untagged<br>m Icon: {fileID: @}<br>n NaveleshLayers 0<br>m StaticEditorFlags: 0<br>ISActive! 1<br>-- Tu14 &amp;465749<br>23 Transforms<br>m ObjectHideFlags! 1<br>9%<br>r complext) { = } = 17-17-17-12-14-15-12-12-13-1<br>CONSULTION CONSULTION CONSULTION CONSULTION CONTRACTION</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Unity Version Control web experience in the Unity dashboard</p>
<p><img src="_page_124_Picture_0.jpeg" alt=""></p>
<p>(UVCS) is a flexible version control system with unique interfaces to support programmers and artists alike. It excels at handling large repos and binary files, and as both a file-based and changeset-based solution, it gives you the capability to download only the specific files you&#39;re working on, rather than the entire project build.</p>
<p>There are three ways to access UVCS: via multiple applications and repositories through the UVCS <a href="https://docs.unity.com/ugs/en-us/manual/devops/manual/version-control-desktop-client">desktop client</a>, by adding it to your projects <a href="https://learn.unity.com/tutorial/how-to-use-the-unity-hub?courseId=6401bbfcedbc2a22aaebd59b">through the Unity Hub,</a> or accessing the repository on Unity cloud via your web browser.</p>
<p>UVCS allows you to:</p>
<ul>
<li>Work knowing that your art assets are securely backed up.</li>
<li>Track ownership of every asset.</li>
<li>Roll back to previous iterations of an asset.</li>
<li>Drive automated processes on a single central repository.</li>
<li>Create branches quickly and securely over multiple platforms.</li>
</ul>
<p>Additionally, UVCS helps you centralize your development with excellent visualization tools. Artists especially will appreciate the user-friendly workflows that encourage tighter integration between development and art teams with <a href="https://docs.plasticscm.com/gluon/plastic-scm-version-control-gluon-guide">the Gluon application,</a> which makes it easier to see and manage just the files they need without dealing with the entire project repository complexity. Besides offering a simplified workflow it also offers tooling that makes it easy to see visual differences in asset versions and easier to contribute to a unified version control environment.</p>
<table>
<thead>
<tr>
<th>1&quot; maingary project_5500@MyBludioAlame@choud<br>rail brans</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Checkin changes Incoming Changes Changesets</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Will download 9 five</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Search fire  Shere delats</td>
<td></td>
</tr>
<tr>
<td></td>
<td>A 2006</td>
<td>1426</td>
<td>Data modified</td>
<td>Changesat</td>
<td>Lack od too the</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>topily</td>
<td></td>
<td></td>
<td>PAV 12/06/2017/02/22 11/01/21 AM</td>
<td></td>
<td>TRANEARINGUERy 20.000</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>cerses</td>
<td></td>
<td></td>
<td>22.06 MI 2/20/20072 52701794</td>
<td></td>
<td>THE NEW SEVER BUIldly SC COST</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>retion Objects</td>
<td></td>
<td></td>
<td>2.07 KB 2723/2002 10:06:08 AM</td>
<td></td>
<td>ITICTORIAN SEVERE (1/2) 7/0.00)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>regate</td>
<td></td>
<td></td>
<td>PRV BC-00 00 2123/2022 10:20 00:28 ARD</td>
<td></td>
<td>Tricher seemBurdly 7d.car</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Langrineser</td>
<td></td>
<td></td>
<td>FAV 12/2012/2012/09/28 10/20/2010</td>
<td></td>
<td>THE NAME JOURNEL COUNT COLLECTIVE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Aprillante</td>
<td></td>
<td></td>
<td>AA BARA 2011/2022 23:50:30 AM</td>
<td></td>
<td>THE THE PAGE A BERE COUNDY THE CHILLER</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stires</td>
<td></td>
<td></td>
<td>MA 12001000 2000/0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>
<td></td>
<td>THE happeares transmy in con-</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MITTER</td>
<td></td>
<td></td>
<td>48.04 MI 2/23/2022 10/06/26 AV</td>
<td></td>
<td>THE PERMILE CONSTITUTION COSE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>T Get Shartes</td>
<td></td>
<td></td>
<td>LAN MI 2/23/2022 30/06/29 AM</td>
<td></td>
<td>THENDESSMENT BANKEY DO DE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>T Paylel Lind forloid.</td>
<td></td>
<td></td>
<td>1:05 KB 2/23/2012 33:00:26 AM</td>
<td></td>
<td>1161 Tour some grand of the States</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1 Pieystech asseconds bardownl</td>
<td></td>
<td></td>
<td>MAV ITEMERE 222/2022 11/28/2111</td>
<td></td>
<td>118790120110110111011101110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Children Co</td>
<td></td>
<td></td>
<td>WE ILL AUTHER EXCENSION IN EDITION FOR COUNTS</td>
<td></td>
<td>FINCTION ARTHIS SECON</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Lieroimage.ching.meta</td>
<td></td>
<td></td>
<td>2.04 KB 212.0/2002 NB 06/26 AM</td>
<td></td>
<td>THChostills and Bundy 3d.001</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cranning right firfood !</td>
<td></td>
<td></td>
<td>10.42 KB 2/23/2022 50:56:26 AM</td>
<td></td>
<td>THE TOOL SEVERE SEVERET BUILDER</td>
<td></td>
<td>Name: 1. introlmage ong</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Chicemprep reportunities hameliers.</td>
<td></td>
<td></td>
<td>214 pyter 2/23/2022 30:10:20 AM</td>
<td></td>
<td>THE THE THE COUNTY Production</td>
<td>State: 059.00: KiB</td>
<td></td>
<td>Parts colly progetty samely in I cock handled charse of  Hers mage and</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Liverearpe</td>
<td></td>
<td></td>
<td>AN INVESTORIOS SECRETIC: ISSUES AN</td>
<td></td>
<td>1997 100 And Annon Charley 2017 11/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1</td>
<td></td>
<td>Created: 2/23/2022 50:50:35 AM<br>Modition: 2114/2022 10:04:58 AM</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cheve mp4 mina</td>
<td></td>
<td></td>
<td>214 Drias 2/21/2012 11:58:26 AM</td>
<td></td>
<td>TOOLOGICOSTERISTORETHERTHU</td>
<td></td>
<td>Last access: WU2002 1155:34 PM</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>The The rip Comments</td>
<td></td>
<td></td>
<td>PH 02/06/2012/2022 10:56:00 AM</td>
<td></td>
<td>THE POST ANY STATIST CHIP CHOUSE FOR CONTRACT FOR COLL CONTAIN CARTER</td>
<td>Fie attributes: Archive<br>Format: png</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tles risk here innous</td>
<td></td>
<td></td>
<td>254 268th 2/23/2022 10/56/26 AM</td>
<td></td>
<td>THE Pennsis and Eggin Production of the Cost</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Firstext.01.00000 Juniord</td>
<td></td>
<td></td>
<td>4/50 KII   2/23/2022 18/04/20 AM</td>
<td></td>
<td>This been seen grandy and pay.</td>
<td></td>
<td>Changemit Creation data</td>
<td>Creatud by</td>
<td>Communt</td>
<td>Branch</td>
</tr>
<tr>
<td>Playbert ULASS STATES STATE LEFECHER</td>
<td></td>
<td></td>
<td>102 byters 2/22/2022 10:10:18 AM</td>
<td></td>
<td>mithed assembliney 3d.com</td>
<td>127</td>
<td></td>
<td>223/2022 33/30/20/44   Hilfred Intergridition  Alting in the executi</td>
<td></td>
<td>Juse</td>
</tr>
<tr>
<td>PayMill Blueset formers</td>
<td></td>
<td></td>
<td>4.05 K3 2/23/2022 10:56:26 AM</td>
<td></td>
<td>million severgistriby 3d con</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>PHOTOGRAPHOTO Concession Turners</td>
<td></td>
<td></td>
<td>MA 2/20/2002 2/20/2002 10:56:26 AM</td>
<td></td>
<td>ITICTION ABPRECENTLy 30.001</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Playfoot Of consist parlouds</td>
<td></td>
<td></td>
<td>5/90 KB 2/23/2022 30/66/28/AM</td>
<td></td>
<td>TRETION SEPSHIPS UNIT POLICY 20.000</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Program (Districtions (count)</td>
<td></td>
<td></td>
<td>162 bytel 272312012 10:00-29 AM</td>
<td></td>
<td>ITAGNE SEPTEMBER SEPTEMBER 1991</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Proytest 10,89249</td>
<td></td>
<td></td>
<td>0:41 KB 2/23/2022 30:00:30 AM</td>
<td></td>
<td>THE THE PROPERTY PLANET THE COLL COLL .</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>PlaySext 70-88845.8MS</td>
<td></td>
<td></td>
<td>182 pyles 2723/2027 33:56:20 AM</td>
<td></td>
<td>1100 Taxas are controlly 20 Coll</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Phig/Nest 15 Julie 15 Julie 11</td>
<td></td>
<td></td>
<td>6/08 KB 2033/2022 33/56/28 4M</td>
<td></td>
<td>ITACTIONS SENIT Churchilly 30 COLL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Playted 15-assetChilla</td>
<td></td>
<td></td>
<td>182 bytel 2/23/2022 10:00:25 AM</td>
<td></td>
<td>THE NUMBER PRESENT BUIlty Soll CONT</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Maybest 16.asset</td>
<td></td>
<td></td>
<td>1.8 KB 2/2 3/2022 10:36 26 AM</td>
<td></td>
<td>THE THE FOR SEVERES LEVEN THE FORM THE FORM THE FOR</td>
<td>Adiding in the assess</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Playted 15-anast.nets</td>
<td></td>
<td></td>
<td>102 bytes 27372022 10:50:26 AM</td>
<td></td>
<td>michemilanen Bunity 30.000</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Paighten 17, mark</td>
<td></td>
<td></td>
<td>8-50 KII 2/73/2022 112 563 267484</td>
<td></td>
<td>118.700 News Candy 2011</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>UVCS offers artist friendly UI even for large assets.</p>
<p><span id="page-125-0"></span><img src="_page_125_Picture_0.jpeg" alt=""></p>
<p>To get started with Unity Version Control, check out the e-book <em><a href="https://unity.com/resources/best-practices-version-control-unity-6">Version control and project</a>  <a href="https://unity.com/resources/best-practices-version-control-unity-6">organization best practices</a></em>.</p>
<h4 id="break-up-large-scenes">Break up large scenes</h4>
<p>Large single Unity scenes do not lend themselves well to collaboration. Break your levels into many smaller scenes so that artists and designers can collaborate effectively on a single level while minimizing the risk of conflicts.</p>
<p>Note that at runtime, your project can load scenes additively using <strong>SceneManager. LoadSceneAsync</strong> passing the <strong>LoadSceneMode.Additive</strong> parameter mode.</p>
<h2 id="-span-id-page-126-0-span-resources-for-advanced-developers-and-artists"><span id="page-126-0"></span>Resources for advanced developers and artists</h2>
<p><img src="_page_126_Picture_1.jpeg" alt=""></p>
<p>You can download many more e-books for advanced Unity developers and creators from <a href="https://unity.com/how-to">the</a>  <a href="https://unity.com/how-to">Unity best practices hub.</a> Choose from over 30 guides, created by industry experts, and Unity engineers and technical artists, that provide best practices for game development and will help you develop efficiently with Unity&#39;s toolsets and systems.</p>
<p>You&#39;ll also find tips, best practices, and news on the <a href="https://unity.com/blog">Unity Blog</a> and <a href="https://forum.unity.com/">Unity community forums,</a> as well as through <a href="https://learn.unity.com/">Unity Learn</a> and the <strong>#unitytips</strong> hashtag.</p>
<p><img src="_page_127_Picture_0.jpeg" alt=""></p>
<p><a href="https://unity.com/">unity.com</a></p>
</body></html>